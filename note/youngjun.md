# 11/12

## 리액트에서 성능 최적화를 위한 방법을 소개해주세요.

https://www.maeil-mail.kr/question/18

첫 번째로, react의 memo가 있습니다. 컴포넌트를 메모이제이션(동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산으 반복 수행을 제거)이 존재합니다.

또한, `useCallBack`, `useMemo`가 존재합니다. useCallback이란, 함수를 메모이제이션하여 불필요한 함수 재생성을 방지합니다. useMemo는 값의 재계산을 방지하여 성능을 최적화합니다. 만약 함수나 값이 변경되지 않을 경우, 리렌더링을 방지할 수 있습니다.

코드 스플리팅 방법 또한 존재합니다. 큰 애플리케이션을 작은 청크로 나누는 방법입니다. react.lazy, Suspense를 사용하여 동적으로 컴포넌트를 로드할 수 있습니다.

### 코드 스플리팅은 어떤 경우에 사용해야 하나요?

초기 로딩 시간이 길어지는 경우에 사용해야 합니다. 초기 로드 시 필요한 핵심 코드만 로드할 수 있도록 하여 초기 로딩 속도를 크게 개선시킬 수 있습니다.

또한, 라우트별 코드 분할이 필요한 경우에도 사용합니다. SPA에서는 각 페이지가 별도의 기능과 UI를 가지므로, 필요한 코드만 분리하여 로드할 수 있습니다. lazy, Suspense를 사용하여 컴포넌트를 동적으로 불러올 때 유용합니다.

---

# 11/13

## 브라우저 렌더링 파이프라인에 대해 설명해주세요.

https://www.maeil-mail.kr/question/19

렌더링 파이프라인이란, 브라우저가 웹 페이지를 화면에 표시하기 위해 거치는 과정입니다. 크게 5가지 과정으로 나누어집니다.

DOM 생성
브라우저가 HTML 파일을 받을 시, byte 단위로 읽기 시작합니다. HTML Parser는 byte들을 문자로 변환하고, 문자를 다시 HTML 토큰으로 변환합니다.

CSSOM 생성
CSS 파일을 파싱하여, CSS 규칙을 기반으로 CSSOM 트리를 생성합니다.

렌더 트리 생성
DOM과 CSSOM을 결합하여 렌더 트리를 생성합니다.

레이아웃
렌더 트리를 사용해 각 요소의 정확한 위치와 크기를 계산합니다.

페인팅
각 요소를 실제로 화면에 그립니다. 성능에 영향을 많이 끼칠 수 있습니다.

컴포지팅
화면에 그려질 요소를 각각의 레이어로 분리, 결합하여 최종 화면을 구성합니다.

`transform`, `opacity`와 같은 속성은 레이아웃이나 페인트 과정을 거치지 않고, 컴포지팅 단계에서만 처리됩니다. 컴포지팅 단계는 GPU 가속을 활용하여 성능을 최적화하고, 최종적으로 표시되는 결과를 빠르게 생성하는데 중요한 역할을 합니다.

---

# 11/14

## 인터넷 창에서 www.google.com을 입력하면 무슨 일이 일어나는지 설명해주세요.

https://www.maeil-mail.kr/question/20

첫 번째로, DNS 조회가 일어납니다.

브라우저는 해당 도메인 이름을 IP주소로 변환합니다. 이 과정을 DNS 조회라고 합니다. 캐시된 DNS 기록을 확인 후, 없으면 DNS 서버에 요청하여 google에 해당하는 IP 주소를 얻습니다.

두 번째로, TCP 연결 수립입니다. IP 주소가 확인되면, 브라우저는 서버와 TCP 연결을 수립합니다.

세 번째로, HTTP 요청입니다. TCP 연결이 수립되면, 브라우저는 HTTP 또는 HTTPS 요청을 보냅니다. 이 과정에서 브라우저와 서버가 암호화된 연결을 설정하기 위해 보안 인증서를 교환, 암호화 키를 협상합니다.

네 번째로, 서버의 응답이 옵니다. HTTP 응답 코드와 같이 전달됩니다.

마지막으로 받은 리소스를 활용해 렌더링 파이프라인을 진행합니다.

---

# 11/18

## React의 render phase와 commit phase에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/30

리액트의 렌더링 과정은 크게 `render phase`와 `commit phase`로 나눌 수 있습니다.

`render phase`란, 리액트가 변화된 상태나 props에 따라 어떤 UI가 변경되어야 할지를 결정하는 단계입니다. 이 과정에서는 실제로 DOM을 업데이트 하지 않고, 변경사항을 가상 DOM에서 계산하여 비교합니다. 순수한 계산과정이므로, 성능에 영향을 주지 않도록 중단 혹은 다시 실행될 수 있습니다. React 18에서 도입된 Concurrent Mode를 통해 비동기적으로 처리가 가능합니다.

`commit phase`는 실제로 변화된 UI를 DOM에 반영하는 단계입니다. 가상 DOM에서 계산된 결과를 실제 DOM에 적용하고, 변화된 UI를 브라우저에 렌더링합니다. 이 과정에서 `useEffect`와 같은 사이드 이펙트가 발생하는 hook들이 실행됩니다.

**`render phase`는 변화된 UI를 결정하는 과정, `commit phase`는 결정된 결과를 실제로 반영하는 단계입니다.**

### render phase와 commit phase는 어떻게 동기화되나요?

**단계적 진행**과 **병목 관리**로 동기화됩니다.

첫 번째로, `render phase`가 완료되면 리액트는 즉시 `commit phase`를 실행하지 않고, 우선순위에 따라 처리합니다. 이를 통해 동기화가 필요한 작업을 효율적으로 관리합니다.

두 번째는 병목 관리입니다. `render phase`의 모든 변경 사항은 Fiber Tree에 준비된 상태에서 넘어갑니다. 그러므로 render와 commit의 일관성이 유지됩니다.

## 예상 꼬리 질문 - Concurrent mode란?

### 동시성이란?

자바스크립트는 싱글 스레드 언어이다.

각 작업은 실행될 때마다 스레드를 블록하고, 해당 작업을 끝마칠 때까지 다른 작업은 실행되지 않는다.

여기서 동시성이란, 독립적으로 실행될 수 있는 여러 조각들로 나누어서 프로그램을 구조화하는 방식이다. 싱글 스레드의 한계를 벗어나, 어플리케이션을 효율적으로 만들 수 있는 방법이다.

주요 특징으로는, 인터럽트가 가능한 렌더링과, 우선순위 기반 스케줄링, 시간 분할, Suspense와 통합이 있다.

인터럽트가 가능한 렌더링이란, 렌더링을 중간에 중단할 수 있어 새로운 업데이트가 필요할 때 즉시 반응이 가능하다.

우선순위 기반 스케줄링이란, 사용자 입력, 애니메이션 등 중요한 작업을 높은 우선순위로 처리하고, 비동기 업데이트 등 덜 중요한 작업은 낮은 우선순위로 처리하여 전체 애플리케이션의 응답성을 유지하는 것이다.

시간 분할이란, 큰 렌더링 작업을 여러 개의 작은 작업으로 나누어 처리하는 것으로, 브라우저가 중간에 사용자 입력 처리가 가능하므로 UI가 더 부드럽게 유지, 사용자 경험을 향상시킬 수 있다.

Suspense와의 통합은, 데이터 패칭이나 비동기 작업의 로딩 상태를 관리하는데 도움을 준다.

---

# 11/19

## 자바스크립트 호이스팅에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/31

`호이스팅 Hoisting`은 자바스크립트가 코드를 실행하기 전에 변수, 함수 선언을 코드의 최상단으로 끌어올리는 것처럼 동작하는 특징입니다. 이를 통해 코드의 선언된 위치와 관계 없이 변수를 사용하는 것처럼 보입니다.

선언의 호이스팅이지, 실제로 변수 값 할당까지 끌어올리지는 않습니다.

```
console.log(myVar);
var myVar = 10;
console.log(myVar);
```

위의 코드에서, 맨 처음 console.log는 undefined가 나옵니다. myVar의 선언은 호이스팅 되었지만, 값이 할당되지는 않습니다. 밑의 console.log에서는 정상적으로 10이 출력됩니다.

함수 선언의 경우, 전체가 호이스팅되므로 함수 호출을 이전에 해도 문제가 되지 않습니다.

`let`, `const`의 경우는 호이스팅이 되지만, 선언하기 전에 접근하려고 하면 `ReferenceError`가 발생합니다. TDZ가 존재하여, 해당 구간에서는 변수에 접근할 수 없기 떄문입니다.

TDZ란, `Temporal Dead Zone`으로, 변수가 선언되었지만 초기화되기 전까지의 구간을 뜻합니다.

```
console.log(myLet);

let myLet = 10;
```

이 경우, 위의 console.log에서는 `ReferenceError`가 발생합니다.
변수 선언은 호이스팅되었지만 초기화는 변수 선언이 실제로 실행될 떄에 일어나기 때문입니다.

결론적으로, var는 선언만 호이스팅되고(초기화 전에 undefined), let과 const의 경우 TDZ의 존재로 인해 초기화 전에 접근하면 ReferenceError가 발생합니다.

---

# 11/20

## 쿠키와 세션, 웹 스토리지의 차이를 설명해주세요.

쿠키와 웹 스토리지는 클라이언트에 저장되고, 세션은 서버에 저장됩니다.

데이터 수명에 따른 차이점 또한 존재합니다. 쿠키는 만료 기간을 설정할 수 있습니다. 세션의 경우 브라우저를 종료 시 만료기간에 상관 없이 종료됩니다.
웹 스토리지는 로컬 스토리지와 세션 스토리지가 있습니다. 로컬 스토리지는 사용자가 데이터를 지우지 않는 이상, 브라우저나 OS를 조욜해도 계속 브라우저에 남아있습니다. 동일한 브라우저를 사용할 때만 해당됩니다. 세션 스토리지의 경우 오리진 뿐만 아닌 브라우저 탭에도 데이터가 종속되어 있기 때문에 윈도우, 브라우저 탭을 닫을 경우 제거된다.

데이터 용량에 따른 차이점도 존재합니다. 쿠키는 약 4KB, 웹 스토리지는 약 5~10MB, 세션은 서버 용량에 따라 다릅니다.

보안적인 측면의 차이점은 다음과 같습니다. 쿠키와 웹 스토리지는 클라이언트 측 저장으로 보안에 취약합니다. 세션의 경우 서버 측 저장으로 비교적 안전하지만, 세션 관리에 주의가 필요합니다.

---

# 11/21

## 자바스크립트 함수에 대해 설명햊쉐요.

자바스크립트 함수는 일급 객체로 취급됩니다.

이를 통해 자바스크립트는 매우 유연하고, 고차 함수를 포함한 다양한 패턴을 구현할 수 있습니다.

자바스크립트 함수의 주요 특징은 다음과 같습니다.

### 일급 객체

자바스크립트에서 함수는 값으로 취급될 수 있습니다. 변수에 할당되거나, 다른 함수의 인자로 전달하거나, 함수의 변환값으로 사용할 수 있습니다.

```
const sayHello = function() { return 'Hello'; };
console.log(sayHello()); // 'Hello'

const executeFunction = function(fn) {
  return fn();
};
console.log(executeFunction(sayHello)); // 'Hello'
```

### 익명 함수, 함수 표현식

자바스크립트에서 이름 없는 함수를 정의할 수 있습니다. 익명 함수는 표현식에서 주로 사용됩니다.

```
const add = function(a, b) {
  return a + b;
};
console.log(add(2, 3)); // 5
```

### 호이스팅

함수 선언은 코드가 실행되기 전 호이스팅됩니다. 함수 선언 이전에 호출이 가능합니다.

함수 표현식의 경우 변수에 할당된 후에 사용이 가능합니다.

```
console.log(declaredFunction()); // 'Declared Function'
function declaredFunction() {
  return 'Declared Function';
}

// 함수 표현식은 할당 후에만 사용할 수 있음
const expressedFunction = function() {
  return 'Expressed Function';
};
console.log(expressedFunction()); // 'Expressed Function'
```

### 클로저

클로저는 함수가 자신이 선언된 환경을 기억하고, 그 외부 스코프에 접근할 수 있는 기능입니다. 이를 통해 함수는 자신이 선언된 스코프 내의 변수를 참조하고 유지할 수 있습니다.

```
function outer() {
  const outerVar = 'I am outer!';

  return function inner() {
    return outerVar; // 외부 변수에 접근 가능
  };
}
const innerFunction = outer();
console.log(innerFunction()); // 'I am outer!'
```

### 고차 함수

함수가 일급 객체이므로, 고차 함수를 정의할 수 있습니다.

고차 함수란, 다른 함수를 인자로 받거나 반환하는 함수입니다.

```
function multiplyBy(factor) {
  return function(num) {
    return num * factor;
  };
}
const double = multiplyBy(2);
console.log(double(5)); // 10
```

### 화살표 함수

더 간결한 문법을 제공하고, this 바인딩에서 기존 함수와 다른 동작을 합니다. 화살표 함수는 선언된 위치의 this 값을 유지하므로 일반 함수와 달리 별도로 this 바인딩을 할 필요가 없습니다.

```
const obj = {
  value: 42,
  method: function() {
    setTimeout(() => {
      console.log(this.value); // 42 (Arrow 함수는 obj의 this를 유지)
    }, 1000);
  }
};
obj.method();
```

---

# 11/25

## CommonJS와 ES Module의 차이점에 대해서 설명해주세요.

`CommonJS`와 `ES Module(ESM)`은 자바스크립트에서 모듈을 관리하고 불러오는 두 가지의 주요 방식입니다.

`CommonJS`은 Node.js 환경에서 사용되며, 모듈을 동기적으로 불러옵니다. 모듈이 로드될 때까지 다음 코드가 실행되지 않습니다. `require` 키워드를 사용해 모듈을 가져오고, `module.exports`를 통해 내보냅니다. 주로 서버측에서 사용됩니다.

`ESM`은 자바스크립트의 공식 표준 모듈 시스템입니다. ES6부터 도입되었으며, 브라우저와 node.js 환경에서 모두 사용이 가능합니다.

모듈을 비동기적으로 로드하며, 모듈을 가져올 때는 import, 내보낼 때는 export를 사용합니다. 또한 정적 분석이 가능하여 트리 쉐이킹과 같은 최적화 작업에도 유리합니다.

`CommonJS`는 동기적이며 주로 서버측에서 사용, `ESM`은 비동기적이고 브라우저, 서버 모두에서 사용이 가능하다는 차이점이 있습니다.

최근에는 `ESM`의 사용이 증가하고 있는 추세입니다. 브라우저와 서버 간의 모듈 호환성, 비동기적 로딩과 트리 쉐이킹 같은 최적화 작업에 유리하다는 점에서 선호됩니다.

---

# 11/26

## 이벤트 전파(event propagation)에 대해서 설명해주세요.

이벤트 전파는 DOM에서 이벤트가 발생하였을 때, 이벤트가 어떤 방식으로 전파되는지를 설명하는 개념입니다.

캡처링, 타겟, 버블링의 3가지 단계로 나눌 수 있습니다.

캡처링의 경우, 이벤트가 DOM 트리 최상위 요소(주로 document, window)에서 시작하며, 이벤트가 발생한 요소를 향해 내려가는 단계입니다. 이 과정에서 상위 요소들에 이벤트 리스너가 있으면 그 순서대로 실행될 수 있습니다.

타깃 단계의 경우, 이벤트가 실제로 발생한 타깃 요소에 도달하는 단계입니다. 타깃 요소에 등록된 이벤트 리스너가 이 시점에 실행됩니다.

버블링 단계의 경우, 타깃 요소에서 이벤트가 발생한 후 다시 상위 요소로 이벤트가 전파되어 올라가는 단계입니다. 상위 요소에 등록된 이벤트 리스너가 실행될 수 있습니다.

대부분의 이벤트는 버블링을 통해 전파되지만, addEventListener의 세 번째 인자로 {capture:ture}를 전달하면 캡처링 단계에서도 이벤트를 처리할 수 있습니다.

웹 페이지에서 요소 간의 상호작용을 하는 데 아주 중요한 역할을 합니다.

---

# 11/27

## 웹 애플리케이션의 성능을 최적화할 수 있는 방법들에 대해서 아는대로 설명해주세요.

첫 번째로, 코드 스플리팅입니다. 자바스크립트 파일을 필요한 부분만 나누어 로드할 수 있습니다. 페이지 로딩 속도를 개선하는데 도움을 줍니다.

두 번쨰로, 레이지 로딩 기법입니다. 페이지에 있는 무거운 리소스(이미지, 비디오 등)을 사용자가 실제로 볼 때만 로드하는 방식입니다. 불필요한 리소스 로딩을 줄여 성능이 높아집니다.

이미지에 대한 최적화도 존재합니다. 물리적 크기를 줄이거나, WebP와 같은 가벼운 포맷으로 변환하는 방법입니다.

캐싱을 활용하면, 로딩된 리소스를 다시 다운로드 하지 않고 브라우저가 캐시된 데이터를 재사용하여 성능을 크게 향상시킬수 있습니다.

자바스크립트 로딩 시에는 비동기 로딩 혹은 지연 로딩을 사용하여 DOM을 차단하지 않도록 할 수 있습니다. 페이지가 로딩되는 동안에도 자바스크립트 파일을 병렬로 불러오거나, 적절한 타이밍에 로드하게 되어 사용자 경험이 쾌적해질 수 있습니다.
