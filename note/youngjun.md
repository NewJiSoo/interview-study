# 11/12

## 리액트에서 성능 최적화를 위한 방법을 소개해주세요.

https://www.maeil-mail.kr/question/18

첫 번째로, react의 memo가 있습니다. 컴포넌트를 메모이제이션(동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산으 반복 수행을 제거)이 존재합니다.

또한, `useCallBack`, `useMemo`가 존재합니다. useCallback이란, 함수를 메모이제이션하여 불필요한 함수 재생성을 방지합니다. useMemo는 값의 재계산을 방지하여 성능을 최적화합니다. 만약 함수나 값이 변경되지 않을 경우, 리렌더링을 방지할 수 있습니다.

코드 스플리팅 방법 또한 존재합니다. 큰 애플리케이션을 작은 청크로 나누는 방법입니다. react.lazy, Suspense를 사용하여 동적으로 컴포넌트를 로드할 수 있습니다.

### 코드 스플리팅은 어떤 경우에 사용해야 하나요?

초기 로딩 시간이 길어지는 경우에 사용해야 합니다. 초기 로드 시 필요한 핵심 코드만 로드할 수 있도록 하여 초기 로딩 속도를 크게 개선시킬 수 있습니다.

또한, 라우트별 코드 분할이 필요한 경우에도 사용합니다. SPA에서는 각 페이지가 별도의 기능과 UI를 가지므로, 필요한 코드만 분리하여 로드할 수 있습니다. lazy, Suspense를 사용하여 컴포넌트를 동적으로 불러올 때 유용합니다.

---

# 11/13

## 브라우저 렌더링 파이프라인에 대해 설명해주세요.

https://www.maeil-mail.kr/question/19

렌더링 파이프라인이란, 브라우저가 웹 페이지를 화면에 표시하기 위해 거치는 과정입니다. 크게 5가지 과정으로 나누어집니다.

DOM 생성
브라우저가 HTML 파일을 받을 시, byte 단위로 읽기 시작합니다. HTML Parser는 byte들을 문자로 변환하고, 문자를 다시 HTML 토큰으로 변환합니다.

CSSOM 생성
CSS 파일을 파싱하여, CSS 규칙을 기반으로 CSSOM 트리를 생성합니다.

렌더 트리 생성
DOM과 CSSOM을 결합하여 렌더 트리를 생성합니다.

레이아웃
렌더 트리를 사용해 각 요소의 정확한 위치와 크기를 계산합니다.

페인팅
각 요소를 실제로 화면에 그립니다. 성능에 영향을 많이 끼칠 수 있습니다.

컴포지팅
화면에 그려질 요소를 각각의 레이어로 분리, 결합하여 최종 화면을 구성합니다.

`transform`, `opacity`와 같은 속성은 레이아웃이나 페인트 과정을 거치지 않고, 컴포지팅 단계에서만 처리됩니다. 컴포지팅 단계는 GPU 가속을 활용하여 성능을 최적화하고, 최종적으로 표시되는 결과를 빠르게 생성하는데 중요한 역할을 합니다.

---

# 11/14

## 인터넷 창에서 www.google.com을 입력하면 무슨 일이 일어나는지 설명해주세요.

https://www.maeil-mail.kr/question/20

첫 번째로, DNS 조회가 일어납니다.

브라우저는 해당 도메인 이름을 IP주소로 변환합니다. 이 과정을 DNS 조회라고 합니다. 캐시된 DNS 기록을 확인 후, 없으면 DNS 서버에 요청하여 google에 해당하는 IP 주소를 얻습니다.

두 번째로, TCP 연결 수립입니다. IP 주소가 확인되면, 브라우저는 서버와 TCP 연결을 수립합니다.

세 번째로, HTTP 요청입니다. TCP 연결이 수립되면, 브라우저는 HTTP 또는 HTTPS 요청을 보냅니다. 이 과정에서 브라우저와 서버가 암호화된 연결을 설정하기 위해 보안 인증서를 교환, 암호화 키를 협상합니다.

네 번째로, 서버의 응답이 옵니다. HTTP 응답 코드와 같이 전달됩니다.

마지막으로 받은 리소스를 활용해 렌더링 파이프라인을 진행합니다.

---

# 11/18

## React의 render phase와 commit phase에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/30

리액트의 렌더링 과정은 크게 `render phase`와 `commit phase`로 나눌 수 있습니다.

`render phase`란, 리액트가 변화된 상태나 props에 따라 어떤 UI가 변경되어야 할지를 결정하는 단계입니다. 이 과정에서는 실제로 DOM을 업데이트 하지 않고, 변경사항을 가상 DOM에서 계산하여 비교합니다. 순수한 계산과정이므로, 성능에 영향을 주지 않도록 중단 혹은 다시 실행될 수 있습니다. React 18에서 도입된 Concurrent Mode를 통해 비동기적으로 처리가 가능합니다.

`commit phase`는 실제로 변화된 UI를 DOM에 반영하는 단계입니다. 가상 DOM에서 계산된 결과를 실제 DOM에 적용하고, 변화된 UI를 브라우저에 렌더링합니다. 이 과정에서 `useEffect`와 같은 사이드 이펙트가 발생하는 hook들이 실행됩니다.

**`render phase`는 변화된 UI를 결정하는 과정, `commit phase`는 결정된 결과를 실제로 반영하는 단계입니다.**

### render phase와 commit phase는 어떻게 동기화되나요?

**단계적 진행**과 **병목 관리**로 동기화됩니다.

첫 번째로, `render phase`가 완료되면 리액트는 즉시 `commit phase`를 실행하지 않고, 우선순위에 따라 처리합니다. 이를 통해 동기화가 필요한 작업을 효율적으로 관리합니다.

두 번째는 병목 관리입니다. `render phase`의 모든 변경 사항은 Fiber Tree에 준비된 상태에서 넘어갑니다. 그러므로 render와 commit의 일관성이 유지됩니다.

## 예상 꼬리 질문 - Concurrent mode란?

### 동시성이란?

자바스크립트는 싱글 스레드 언어이다.

각 작업은 실행될 때마다 스레드를 블록하고, 해당 작업을 끝마칠 때까지 다른 작업은 실행되지 않는다.

여기서 동시성이란, 독립적으로 실행될 수 있는 여러 조각들로 나누어서 프로그램을 구조화하는 방식이다. 싱글 스레드의 한계를 벗어나, 어플리케이션을 효율적으로 만들 수 있는 방법이다.

주요 특징으로는, 인터럽트가 가능한 렌더링과, 우선순위 기반 스케줄링, 시간 분할, Suspense와 통합이 있다.

인터럽트가 가능한 렌더링이란, 렌더링을 중간에 중단할 수 있어 새로운 업데이트가 필요할 때 즉시 반응이 가능하다.

우선순위 기반 스케줄링이란, 사용자 입력, 애니메이션 등 중요한 작업을 높은 우선순위로 처리하고, 비동기 업데이트 등 덜 중요한 작업은 낮은 우선순위로 처리하여 전체 애플리케이션의 응답성을 유지하는 것이다.

시간 분할이란, 큰 렌더링 작업을 여러 개의 작은 작업으로 나누어 처리하는 것으로, 브라우저가 중간에 사용자 입력 처리가 가능하므로 UI가 더 부드럽게 유지, 사용자 경험을 향상시킬 수 있다.

Suspense와의 통합은, 데이터 패칭이나 비동기 작업의 로딩 상태를 관리하는데 도움을 준다.

---

# 11/19

## 자바스크립트 호이스팅에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/31

`호이스팅 Hoisting`은 자바스크립트가 코드를 실행하기 전에 변수, 함수 선언을 코드의 최상단으로 끌어올리는 것처럼 동작하는 특징입니다. 이를 통해 코드의 선언된 위치와 관계 없이 변수를 사용하는 것처럼 보입니다.

선언의 호이스팅이지, 실제로 변수 값 할당까지 끌어올리지는 않습니다.

```
console.log(myVar);
var myVar = 10;
console.log(myVar);
```

위의 코드에서, 맨 처음 console.log는 undefined가 나옵니다. myVar의 선언은 호이스팅 되었지만, 값이 할당되지는 않습니다. 밑의 console.log에서는 정상적으로 10이 출력됩니다.

함수 선언의 경우, 전체가 호이스팅되므로 함수 호출을 이전에 해도 문제가 되지 않습니다.

`let`, `const`의 경우는 호이스팅이 되지만, 선언하기 전에 접근하려고 하면 `ReferenceError`가 발생합니다. TDZ가 존재하여, 해당 구간에서는 변수에 접근할 수 없기 떄문입니다.

TDZ란, `Temporal Dead Zone`으로, 변수가 선언되었지만 초기화되기 전까지의 구간을 뜻합니다.

```
console.log(myLet);

let myLet = 10;
```

이 경우, 위의 console.log에서는 `ReferenceError`가 발생합니다.
변수 선언은 호이스팅되었지만 초기화는 변수 선언이 실제로 실행될 떄에 일어나기 때문입니다.

결론적으로, var는 선언만 호이스팅되고(초기화 전에 undefined), let과 const의 경우 TDZ의 존재로 인해 초기화 전에 접근하면 ReferenceError가 발생합니다.


---

# 11/20

## 쿠키와 세션, 웹 스토리지의 차이를 설명해주세요.

쿠키와 웹 스토리지는 클라이언트에 저장되고, 세션은 서버에 저장됩니다.

데이터 수명에 따른 차이점 또한 존재합니다. 쿠키는 만료 기간을 설정할 수 있습니다. 세션의 경우 브라우저를 종료 시 만료기간에 상관 없이 종료됩니다. 
웹 스토리지는 로컬 스토리지와 세션 스토리지가 있습니다. 로컬 스토리지는 사용자가 데이터를 지우지 않는 이상, 브라우저나 OS를 조욜해도 계속 브라우저에 남아있습니다. 동일한 브라우저를 사용할 때만 해당됩니다. 세션 스토리지의 경우 오리진 뿐만 아닌 브라우저 탭에도 데이터가 종속되어 있기 때문에 윈도우, 브라우저 탭을 닫을 경우 제거된다.

데이터 용량에 따른 차이점도 존재합니다. 쿠키는 약 4KB, 웹 스토리지는 약 5~10MB, 세션은 서버 용량에 따라 다릅니다.

보안적인 측면의 차이점은 다음과 같습니다. 쿠키와 웹 스토리지는 클라이언트 측 저장으로 보안에 취약합니다. 세션의 경우 서버 측 저장으로 비교적 안전하지만, 세션 관리에 주의가 필요합니다.