## 브라우저의 성능 최적화를 할 수 있는 방법에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/40

우선 코드 스플리팅을 통해 자바스크립트 파일을 전부 한꺼번에 불러오는 대신 당장 필요한 부분만 먼저 로드하여 페이지 로딩 속도를 개선할 수 있습니다.
그리고 이미지나 비디오 같은 무거운 리소스에 대해서 레이지 로딩을 적용할 수도 있습니다. 사용자가 페이지를 스크롤해서 밑에 있는 이미지가 필요해지면 그때 가서 이미지를 로드하는 식으로 구현합니다. 이미지에 대해서는 이미지 최적화로 파일 크기를 줄이거나 가벼운 포맷으로 변환할 수도 있습니다.
이외에도 브라우저가 캐싱을 할 수도 있고, 불필요한 DOM 크기를 줄이거나 script 태그에 async나 defer 속성을 사용해서 비동기 로딩을 하는 방법도 있습니다.

## 이벤트 전파(event propagation)에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/39

버튼 클릭 같은 이벤트가 발생했을 때, 이벤트 전파 순서는 캡처링, 타깃, 버블링 순서입니다.
DOM 트리의 최상위 요소(document 또는 window)부터 시작하여, 이벤트가 발생한 타깃 요소(여기서는 버튼)까지 내려가며 이벤트를 탐색하는 과정을 캡처링이라고 합니다.
두 번째 타깃 단계에서는 이벤트 리스너가 타깃 요소에서 실행됩니다
세 번째 버블링 단계에서는 다시 점점 상위 요소로 이벤트가 전파됩니다.
기본적으로 이벤트 리스너는 버블링 단계에서 실행되지만, 캡처링 단계에서 실행되도록 설정할 수도 있습니다.

#### 추가질문 1: 버블링은 왜 필요한가?

이벤트 위임(Event Delegation): 상위 요소에서 한 번에 이벤트를 처리 (예를 들어 리스트의 각 메뉴를 클릭했을 때)
팝업 외부를 클릭하면 팝업이 닫히는 등의 이벤트를 처리하기에 유용합니다.

#### 추가질문 2: 이벤트 전파 멈추는 방법

`event.stopPropagation()`을 호출하면, 이벤트는 버블링 단계로 더 이상 전파되지 않습니다.
예시: 모달 바깥을 클릭하면 모달이 닫히게 했을 때, stopPropagation 안 하면 모달 내부를 클릭해도 닫힘.

## CommonJS와 ES Module의 차이점에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/38

commonJS와 ES Module은 자바스크립트에서 모듈을 불러오고 내보내는 두 가지 방식입니다.
CommonJS는 자바스크립트 초창기부터 쓰던 방식인데, 동기적으로 로드하고 트리 쉐이킹이 지원되지 않습니다. require로 모듈을 동적으로 불러올 수 있기 때문입니다.
ES Module은 ES6때 나온 새로운 모듈 시스템입니다. Promise를 기반으로 비동기적으로 작동되며, 정적 분석이 가능해 트리 쉐이킹을 할 수 있습니다.
ES Module 방식을 쓰려면 package.json에서 `"type": "module"` 을 명시해야 합니다. 최근에는 대부분 ES Module 방식을 쓰지만, 레거시 문제로 CommonJS도 여전히 사용됩니다.

#### 추가질문: 트리 쉐이킹이란?

자바스크립트 번들러(Webpack, Rollup 등)가 사용하지 않는 코드를 자동으로 제거해서 최종 번들 크기를 줄이는 최적화 기법.
트리 쉐이킹이 작동하려면 코드가 정적 구조로 작성되어 어떤 모듈이 어디서 사용될지 컴파일 시점에 알 수 있어야 한다. CommonJS는 require로 모듈을 동적으로 불러올 수 있어서 정적 분석이 어렵다.

## 자바스크립트 함수에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/33

자바스크립트의 함수는 일급 객체입니다. 값처럼 자유롭게 변수에 할당하거나, 함수에 인자 또는 리턴값으로 쓰이거나, 런타임 중에 함수가 새로 생성되는 것이 가능합니다. 그래서 고차 함수 같은 식으로도 사용될 수 있습니다. (고차 함수가 뭐죠: 다른 함수를 인자로 받거나 리턴값으로 뱉는 함수입니다. Array의 map이나 forEach 같은 함수들이 있습니다.)
그리고 자바스크립트 함수는 lexical scope를 따릅니다. 함수의 호출 위치와는 관계없이 함수가 **정의**된 위치에 따라 변수에 접근할 수 있는 scope가 결정됩니다. 그래서 클로저가 가능합니다. 클로저는 내부 함수가 외부 함수의 변수 스코프를 기억해서 함수 실행이 종료된 후에도 또 호출할 때 계속 참조할 수 있는 기능을 말합니다.
화살표 함수의 경우에는 this를 렉시컬 스코프에 바인딩하기 때문에, 콜백 함수에서 기존 함수보다 더 직관적으로 사용할 수 있습니다. 다만, 생성자 함수로는 사용할 수 없고, arguments 객체를 지원하지 않는 등의 제약이 있습니다.

## 쿠키, 세션, 웹스토리지의 차이를 설명해보세요.

쿠키는 브라우저에 저장되고, http 요청마다 서버로 전송됩니다.
세션은 서버에 저장되고, 브라우저는 세션 id를 쿠키로 저장하거나 url에 포함시켜서 서버에 전달합니다. 브라우저를 닫으면 기본적으로는 세션이 종료되지만 유효기간을 설정해서 지속되게 할 수 있습니다. 데이터가 서버에 있으므로 보안에 더 적합하지만, 대규모 사용자가 접속하면 서버 메모리를 많이 차지할 수 있습니다.
웹 스토리지는 브라우저만 저장하고 서버로 전송되지 않습니다. 로컬 스토리지는 삭제하지 않는 한 영구적으로 저장되고, 세션 스토리지는 브라우저 탭을 닫으면 삭제됩니다.

#### 추가질문: 각각 어떤 상황에서 사용하면 적절한가요?

쿠키는 클라이언트와 서버 간 상태를 유지하기 위해 사용됩니다. 예를 들어, 세션 ID나 사용자 인증 토큰을 쿠키에 저장하면 서버와의 상태를 동기화할 수 있습니다.사용자의 행동을 추적하거나 간단한 사용자 설정 등을 저장할 때도 쓰입니다.
세션은 클라이언트에 저장하면 안 되는 보안이 중요한 데이터를 저장할 때 쓰입니다. 클라이언트는 세션 ID만 저장하며, 실제 데이터는 서버에서 관리하기 때문에 민감한 정보를 안전하게 보호할 수 있습니다.
웹 스토리지는 서버 요청 없이 데이터를 활용할 때 쓰입니다. 예를 들어 비회원 장바구니 기능을 로컬스토리지에 저장해두고 주문하기를 누르면 회원가입 창으로 이동시킬 수 있습니다. 폼 입력과 같이 현재 탭을 닫으면 삭제되게 하고 싶을 때는 세션 스토리지를 씁니다.

## 자바스크립트 호이스팅에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/31

변수와 함수 선언을 제일 먼저 끌어올려서 하는 것을 호이스팅이라고 합니다. 자바스크립트에서는 변수와 함수 선언을 코드 어디에서 하더라도 최상단에서 선언한 것처럼 호이스팅이 됩니다. 그래서 함수 호출 코드가 더 위에 있고 밑에서 함수를 선언한다고 해도 문제가 없습니다. 하지만 호이스팅되는 것은 선언뿐이지 값 할당은 호이스팅되지 않습니다.
그래서 초기화 전까지 var로 선언된 변수는 undefined로 취급되는데, let과 const는 선언되었어도 초기화 전까지는 접근할 수 없습니다 - ReferenceError가 발생합니다.

### 추가질문: var, let, const의 차이를 설명해주세요.

let과 const는 var의 한계를 보완하기 위해 ES6에서부터 도입된 문법입니다.
var는 함수 스코프를 가집니다. 함수 내부에서 선언되면 그 함수 안에서만 동작하는데, 함수 외부에서 선언된 var는 전역 변수처럼 동작합니다. if문 같은 블록 안에서 선언되더라도 블록 밖에서 역시 접근 가능합니다. 반면 let과 const는 블록 스코프를 가지므로 블록 안에서 선언하면 블록 밖에서 접근할 수 없습니다.
또한 var는 같은 스코프 내에서 재선언이 가능한데 let과 const는 재선언이 불가능합니다. 값을 재할당하는 것은 var와 let에서 가능하고 const는 상수 취급되기 때문에 재할당이 불가능합니다. 다만 객체나 배열의 내부 값을 변경하는 것은 가능합니다. 주소값이 변하지 않기 때문에.
마지막으로 호이스팅 시에 var는 초기화 전에 undefined로 취급되지만 let과 const는 초기화 전에 접근하면 레퍼런스 에러가 뜹니다.
최근에는 var는 잘 쓰이지 않고, const를 주로 사용하면서 재할당이 필요한 경우에만 let을 사용하는 것을 권장합니다.

## 리액트의 render phase와 commit phase에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/30

리액트의 렌더링 과정은 크게 렌더 페이즈와 커밋 페이즈로 나눌 수 있습니다. 렌더 페이즈는 props나 state의 변화에 따라서 어떻게 UI를 변경할지를 가상 DOM에서 먼저 계산해보는 단계입니다. 이 단계는 브라우저와 독립적으로 작동하며, 작업 우선순위에 따라 비동기적으로 실행될 수 있습니다. 이렇게 계산된 내용을 커밋 페이즈에서 실제 DOM에 반영합니다.

## 인터넷 창에서 www.google.com 를 입력하면 무슨 일이 일어나는지 설명해주세요.

https://www.maeil-mail.kr/question/20

우선 DNS 조회부터 시작합니다. www google.com 이라는 도메인 이름을 브라우저가 IP 주소로 변환하기 위해서 DNS를 조회하는데요, 캐시된 DNS 기록이 있는지 먼저 확인하고 없으면 로컬 DNS 서버에 요청해서 해당 IP 주소를 얻습니다.
그 다음에 브라우저와 서버 간에 3-way 핸드셰이크로 TCP 연결을 합니다. TCP는 데이터를 신뢰성 있게 전달하기 위한 연결 프로토콜인데요, 브라우저가 먼저 SYN 패킷을 전송하고, 서버가 그걸 받아서 응답으로 SYN-ACK 패킷을 전송하고, 다시 브라우저가 응답을 받고 ACK 패킷을 보냄으로써 연결이 완료됩니다.
그러면 이제 브라우저가 GET 요청 같은 HTTP 요청을 보낼 수 있습니다. HTTPS를 사용한다면 이 단계에서 SSL-TLS 핸드셰이크를 수행함으로써 보안 인증서를 교환하고 암호화 키를 협상해서 서버의 신원을 확인하고 이후 통신이 암호화 상태로 진행될 수 있게 합니다.
서버로부터 요청에 대한 응답이 오면, 브라우저는 받은 리소스들을 바탕으로 브라우저 렌더링 파이프라인을 진행합니다.

## 브라우저 렌더링 파이프라인에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/19

우선 브라우저가 서버에서 html 코드부터 바이트로 가져옵니다. 그리고 파서가 이걸 문자로 변환하고, 문자를 다시 html 토큰으로 파싱해서 DOM 트리를 만듭니다. 그 다음에 CSS도 마찬가지로 트리를 생성하고, DOM과 CSSOM을 합쳐서 렌더 트리를 생성합니다. 그 렌더 트리를 가지고 뷰포트에 따라서 레이아웃을 계산하고, 페인팅 작업에 들어갑니다. 마지막으로 페인팅된 요소들을 각각의 레이어로 분리하고, 이 레이어들을 결합해서 최종적으로 컴포지팅, 화면을 구성하게 됩니다.

## 리액트에서 성능 최적화를 위한 방법들을 설명해주세요.

https://www.maeil-mail.kr/question/18

리액트에서 성능 최적화를 하려면 첫 번째, 불필요한 리렌더링을 줄이거나, 두 번째, 코드 로딩 시간을 줄여야 합니다.
첫 번째로 불필요한 리렌더링을 줄이는 방법으로는 메모이제이션이 있습니다. 이미 계산된 결과를 저장해두고 다음에 같은 계산을 반복하는 대신 불러오는 방법인데요. 원래 리액트에서 부모 컴포넌트가 리렌더링될 때 자식도 같이 리렌더링되는데, 부모가 변경되었지만 자식에게 영향이 없는 경우도 있습니다. 자식 컴포넌트를 `React.memo`로 감싸두면 props가 변경되었는지를 확인해서 이 자식에게 오는 props가 변경되지 않았다면 리렌더링하지 않습니다. 하지만 props에 전달되는 값이 함수나 객체일 경우에는, 부모가 리렌더링될 때 새로운 함수나 객체가 생성되어 props가 변경된 것으로 인식되는 한계가 있을 수 있습니다. 그래서 props로 함수가 전달될 때는 useCallback으로 함수를 메모이제이션하고, props가 객체일 때나 아니면 긴 배열의 필터링 결과 같이 비용이 큰 계산을 메모이제이션해야할 때는 useMemo를 사용합니다.
다만 메모이제이션에도 비용이 들고, 리액트도 더 효율적인 리렌더링 방식으로 업데이트되고 있기 때문에 많이 복잡한 계산이 아니면 오히려 성능이 악화될 수도 있어 꼭 필요할 때만 쓰는 게 좋습니다 .
두 번째로 코드 스플리팅을 통해 코드 로딩 시간을 줄일 수 있습니다. 앱이 커서 초기 로딩 속도가 느리거나 페이지별로 필요한 코드가 다를 때, `React.lazy`를 써서 특정 컴포넌트는 필요할 때가 되면 불러오도록 할 수 있습니다.
