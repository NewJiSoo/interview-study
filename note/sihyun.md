## 쿠키, 세션, 웹스토리지의 차이를 설명해보세요.

쿠키는 브라우저에 저장되고, http 요청마다 서버로 전송됩니다.
세션은 서버에 저장되고, 브라우저는 세션 id를 쿠키로 저장하거나 url에 포함시켜서 서버에 전달합니다. 브라우저를 닫으면 기본적으로는 세션이 종료되지만 유효기간을 설정해서 지속되게 할 수 있습니다. 데이터가 서버에 있으므로 보안에 더 적합하지만, 대규모 사용자가 접속하면 서버 메모리를 많이 차지할 수 있습니다.
웹 스토리지는 브라우저만 저장하고 서버로 전송되지 않습니다. 로컬 스토리지는 삭제하지 않는 한 영구적으로 저장되고, 세션 스토리지는 브라우저 탭을 닫으면 삭제됩니다.

#### 추가질문: 각각 어떤 상황에서 사용하면 적절한가요?

쿠키는 클라이언트와 서버 간 상태를 유지하기 위해 사용됩니다. 예를 들어, 세션 ID나 사용자 인증 토큰을 쿠키에 저장하면 서버와의 상태를 동기화할 수 있습니다.사용자의 행동을 추적하거나 간단한 사용자 설정 등을 저장할 때도 쓰입니다.
세션은 클라이언트에 저장하면 안 되는 보안이 중요한 데이터를 저장할 때 쓰입니다. 클라이언트는 세션 ID만 저장하며, 실제 데이터는 서버에서 관리하기 때문에 민감한 정보를 안전하게 보호할 수 있습니다.
웹 스토리지는 서버 요청 없이 데이터를 활용할 때 쓰입니다. 예를 들어 비회원 장바구니 기능을 로컬스토리지에 저장해두고 주문하기를 누르면 회원가입 창으로 이동시킬 수 있습니다. 폼 입력과 같이 현재 탭을 닫으면 삭제되게 하고 싶을 때는 세션 스토리지를 씁니다.

## 자바스크립트 호이스팅에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/31

변수와 함수 선언을 제일 먼저 끌어올려서 하는 것을 호이스팅이라고 합니다. 자바스크립트에서는 변수와 함수 선언을 코드 어디에서 하더라도 최상단에서 선언한 것처럼 호이스팅이 됩니다. 그래서 함수 호출 코드가 더 위에 있고 밑에서 함수를 선언한다고 해도 문제가 없습니다. 하지만 호이스팅되는 것은 선언뿐이지 값 할당은 호이스팅되지 않습니다.
그래서 초기화 전까지 var로 선언된 변수는 undefined로 취급되는데, let과 const는 선언되었어도 초기화 전까지는 접근할 수 없습니다 - ReferenceError가 발생합니다.

### 추가질문: var, let, const의 차이를 설명해주세요.

let과 const는 var의 한계를 보완하기 위해 ES6에서부터 도입된 문법입니다.
var는 함수 스코프를 가집니다. 함수 내부에서 선언되면 그 함수 안에서만 동작하는데, 함수 외부에서 선언된 var는 전역 변수처럼 동작합니다. if문 같은 블록 안에서 선언되더라도 블록 밖에서 역시 접근 가능합니다. 반면 let과 const는 블록 스코프를 가지므로 블록 안에서 선언하면 블록 밖에서 접근할 수 없습니다.
또한 var는 같은 스코프 내에서 재선언이 가능한데 let과 const는 재선언이 불가능합니다. 값을 재할당하는 것은 var와 let에서 가능하고 const는 상수 취급되기 때문에 재할당이 불가능합니다. 다만 객체나 배열의 내부 값을 변경하는 것은 가능합니다. 주소값이 변하지 않기 때문에.
마지막으로 호이스팅 시에 var는 초기화 전에 undefined로 취급되지만 let과 const는 초기화 전에 접근하면 레퍼런스 에러가 뜹니다.
최근에는 var는 잘 쓰이지 않고, const를 주로 사용하면서 재할당이 필요한 경우에만 let을 사용하는 것을 권장합니다.

## 리액트의 render phase와 commit phase에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/30

리액트의 렌더링 과정은 크게 렌더 페이즈와 커밋 페이즈로 나눌 수 있습니다. 렌더 페이즈는 props나 state의 변화에 따라서 어떻게 UI를 변경할지를 가상 DOM에서 먼저 계산해보는 단계입니다. 이 단계는 브라우저와 독립적으로 작동하며, 작업 우선순위에 따라 비동기적으로 실행될 수 있습니다. 이렇게 계산된 내용을 커밋 페이즈에서 실제 DOM에 반영합니다.

## 인터넷 창에서 www.google.com 를 입력하면 무슨 일이 일어나는지 설명해주세요.

https://www.maeil-mail.kr/question/20

우선 DNS 조회부터 시작합니다. www google.com 이라는 도메인 이름을 브라우저가 IP 주소로 변환하기 위해서 DNS를 조회하는데요, 캐시된 DNS 기록이 있는지 먼저 확인하고 없으면 로컬 DNS 서버에 요청해서 해당 IP 주소를 얻습니다.
그 다음에 브라우저와 서버 간에 3-way 핸드셰이크로 TCP 연결을 합니다. TCP는 데이터를 신뢰성 있게 전달하기 위한 연결 프로토콜인데요, 브라우저가 먼저 SYN 패킷을 전송하고, 서버가 그걸 받아서 응답으로 SYN-ACK 패킷을 전송하고, 다시 브라우저가 응답을 받고 ACK 패킷을 보냄으로써 연결이 완료됩니다.
그러면 이제 브라우저가 GET 요청 같은 HTTP 요청을 보낼 수 있습니다. HTTPS를 사용한다면 이 단계에서 SSL-TLS 핸드셰이크를 수행함으로써 보안 인증서를 교환하고 암호화 키를 협상해서 서버의 신원을 확인하고 이후 통신이 암호화 상태로 진행될 수 있게 합니다.
서버로부터 요청에 대한 응답이 오면, 브라우저는 받은 리소스들을 바탕으로 브라우저 렌더링 파이프라인을 진행합니다.

## 브라우저 렌더링 파이프라인에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/19

우선 브라우저가 서버에서 html 코드부터 바이트로 가져옵니다. 그리고 파서가 이걸 문자로 변환하고, 문자를 다시 html 토큰으로 파싱해서 DOM 트리를 만듭니다. 그 다음에 CSS도 마찬가지로 트리를 생성하고, DOM과 CSSOM을 합쳐서 렌더 트리를 생성합니다. 그 렌더 트리를 가지고 뷰포트에 따라서 레이아웃을 계산하고, 페인팅 작업에 들어갑니다. 마지막으로 페인팅된 요소들을 각각의 레이어로 분리하고, 이 레이어들을 결합해서 최종적으로 컴포지팅, 화면을 구성하게 됩니다.

## 리액트에서 성능 최적화를 위한 방법들을 설명해주세요.

https://www.maeil-mail.kr/question/18

리액트에서 성능 최적화를 하려면 첫 번째, 불필요한 리렌더링을 줄이거나, 두 번째, 코드 로딩 시간을 줄여야 합니다.
첫 번째로 불필요한 리렌더링을 줄이는 방법으로는 메모이제이션이 있습니다. 이미 계산된 결과를 저장해두고 다음에 같은 계산을 반복하는 대신 불러오는 방법인데요. 원래 리액트에서 부모 컴포넌트가 리렌더링될 때 자식도 같이 리렌더링되는데, 부모가 변경되었지만 자식에게 영향이 없는 경우도 있습니다. 자식 컴포넌트를 `React.memo`로 감싸두면 props가 변경되었는지를 확인해서 이 자식에게 오는 props가 변경되지 않았다면 리렌더링하지 않습니다. 하지만 props에 전달되는 값이 함수나 객체일 경우에는, 부모가 리렌더링될 때 새로운 함수나 객체가 생성되어 props가 변경된 것으로 인식되는 한계가 있을 수 있습니다. 그래서 props로 함수가 전달될 때는 useCallback으로 함수를 메모이제이션하고, props가 객체일 때나 아니면 긴 배열의 필터링 결과 같이 비용이 큰 계산을 메모이제이션해야할 때는 useMemo를 사용합니다.
다만 메모이제이션에도 비용이 들고, 리액트도 더 효율적인 리렌더링 방식으로 업데이트되고 있기 때문에 많이 복잡한 계산이 아니면 오히려 성능이 악화될 수도 있어 꼭 필요할 때만 쓰는 게 좋습니다 .
두 번째로 코드 스플리팅을 통해 코드 로딩 시간을 줄일 수 있습니다. 앱이 커서 초기 로딩 속도가 느리거나 페이지별로 필요한 코드가 다를 때, `React.lazy`를 써서 특정 컴포넌트는 필요할 때가 되면 불러오도록 할 수 있습니다.
