## CSS Flexbox와 Grid의 차이점에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/51

둘 다 레이아웃을 짤 때 쓰는 건데, flex는 1차원 레이아웃이고 grid는 2차원 레이아웃입니다. flex는 row나 column 중 한 방향으로 정렬하는 거고, grid는 row와 column을 모두 사용합니다.
그래서 grid는 복잡한 레이아웃을 구성하거나, 웹페이지 전체 구조를 잡을 때 쓰면 좋습니다. 카드 레이아웃이나 갤러리 형식처럼요. grid-template-row나 col 같은 속성으로 row와 column의 크기를 미리 정해놓고 그 셀 안에 요소를 배치하는 방식입니다.
반면 flex는 주로 요소가 컨테이너 크기나 위치에 맞춰서 자동으로 정렬되기 때문에 유연하게 요소가 추가되거나 삭제될 때 사용하기 좋습니다. 가로나 세로 한 방향으로 요소들을 한 줄로 정렬하고 간격을 조절하기에 좋습니다.

## SSR(Server Side Rendering)에 대해 설명해주세요.

https://www.maeil-mail.kr/question/48

서버사이드렌더링은 초기 화면을 클라이언트가 아니라 서버가 렌더링해서 렌더 트리까지 완성된 html을 클라이언트한테 주고 클라이언트는 파싱만 하는 개념입니다. 이후에 hydration 과정에서 이벤트 리스너 붙이고 하는 자바스크립트 동작을 실행해서 정적인 화면을 동적으로 전환합니다. 원래 기본적인 클라이언트사이드렌더링에서는 서버에서 비어 있는 뼈대 html만 제공하고 브라우저에서 필요한 자바스크립트 번들을 다운받고 실행해서 DOM 트리부터 그리면서 동적으로 화면을 그립니다.
SSR은 초기 로딩 속도가 빠르고 SEO에 유리합니다. 검색 엔진이 크롤링할 때 컨텐츠 인식하기가 쉽기 때문입니다. 그래서 SEO가 중요한 커머스나 블로그 같은 서비스에 특히 적합합니다. 단점은 CSR보다 UI 그리는 건 빠른데 상호작용 되기까지는 비슷한 시간이 걸리니까 사용자 입장에서 버튼은 보이는데 클릭이 안 되는 경험을 할 수도 있습니다. 그리고 서버의 부하가 크고, 양쪽 모두의 렌더링을 고려하므로 개발 과정이 좀 더 복잡합니다.

## 웹 접근성의 개념과 개선 방법에 대해 설명해주세요.

https://www.maeil-mail.kr/question/47

웹 접근성은 장애인이나 노약자 등 취약한 사람들도 웹페이지를 잘 이용할 수 있는지에 대한 것입니다. 예를 들어 시각 장애인이 스크린 리더로 웹 페이지를 '듣기' 위해서는 다 div로 도배된 것보다는 button, li, h1 등 html 태그에 의미가 적확하게 담겨 있고 html 구조가 단순할수록 좋습니다. 충분하지 않을 때는 ARIA 속성을 넣어서 동적 컨텐츠나 복잡한 UI를 제대로 인식할 수 있게 도울 수도 있습니다. 혹은 focus-visible 같은 걸로 키보드 내비게이션을 지원할 수도 있습니다.
이런 웹 접근성 개선은 장애인 사용자에게만 좋은 게 아니라 모두에게 이점이 있습니다. 이렇게 코드를 짰을 때 SEO가 좋아져서 검색에 노출이 더 잘 된다거나 크롤링이 용이해진다거나, 하다못해 개발자 입장에서도 가독성이 좋아집니다.
저는 웹 접근성 관련된 부분은 약간 컨벤션처럼 가져가는 게 좋다고 생각합니다. 나중에 덧붙이려고 하면 고민이 많이 되고 어려운데, 처음 코드를 칠 때부터 좀 생각 없이 하게 만들면 좀 품이 덜 들면서도 최소한의 퀄리티가 나오는 것 같습니다. 그래서 처음부터 나쁜 습관을 들이지 않으려고 하는 편입니다. 그렇게 컨벤션으로 커버하지 못한 케이스는, 일일이 고려하기엔 너무 다양한 장애의 종류가 있기 때문에 실제 고객에게서 피드백이 왔을 때 맞춤형으로 반영을 하게 될 것 같습니다.

## useEffect와 useLayoutEffect의 차이점에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/46

useEffect는 화면이 실제로 사용자에게 그려진 후에 실행됩니다. 그래서 useEffect는 보통 데이터를 가져오는 작업이나 이벤트 리스너 추가 등 화면에 직접적인 영향을 주지 않는 작업에 주로 사용됩니다.
반면 useLayoutEffect는 화면에 내용이 그려지기 전에 모든 작업이 완료됩니다. 그래서 DOM의 크기를 측정해서 다른 요소의 위치를 조정해야 할 때 useLayoutEffect를 사용하면 즉각적으로 변경사항이 반영되어 화면 깜빡임이나 불필요한 재렌더링을 방지할 수 있습니다. 주의할 점은 useLayoutEffect는 동기적으로 실행되기 때문에 렌더링을 느려지게 할 수 있습니다.

## async/await에 대해 설명해보세요.

async랑 await은 자바스크립트에서 Promise를 좀 더 쉽게 쓸 수 있도록 해주는 키워드인데요.
함수 앞에 async 선언을 하면 그 함수는 Promise 객체를 반환합니다. Promise 객체에는 진행 상태를 나타내는 pending, fulfilled, rejected 상태도 저장되어 있고, 성공하면 결과값 데이터, 실패하면 에러 정보도 저장됩니다. 그리고 `.then()`, `.catch()`, `.finally()` 같은 메서드가 포함되어 있어서 Promise의 상태 변화에 따라 적절한 동작을 연결할 수 있습니다.
async 선언을 한 함수 안에서는 await을 쓸 수 있게 됩니다. 예를 들어 서버에 get 요청 보내서 데이터 받아오는 함수 앞에 await을 선언합니다. 그럼 그거 하는 동안에 async 함수 안에 있는 다른 코드들은 실행되지 않고 대기합니다. 하지만 async 밖에 있는 코드들은 기다리지 않고 실행됩니다.
이렇게 시간이 오래 걸리는 작업이 완료될 때까지 기다리지 않고 다음 작업을 처리할 수 있는 방식을 비동기 프로그래밍이라고 합니다.

## 리액트에서 index를 key값으로 사용하면 안되는 이유에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/42

배열의 인덱스 말씀하시는 거죠? 그러면 배열 순서가 바뀌거나 했을 때 문제가 생길 수 있습니다. 배열 중간에 새로운 값이 추가되거나 삭제될 수도 있고요. 그러면 2번 폼에 입력한 값이 3번 폼으로 잘못 연결된다든지 하는 버그가 발생할 수도 있고, 그러지 않더라도 변경된 부분부터 그 이후 인덱스는 싹 다 바뀌기 때문에 렌더링을 다 새로 해야 합니다.

#### key로 사용되는 고유한 값의 생성 방법에는 어떤 것들이 있나요?

데이터베이스에서 오는 고유 id값을 사용하는 것이 제일 안전하다고 생각합니다. 그런 게 여의치 않으면 UUID 같은 전역적으로 고유한 id를 생성해주는 라이브러리를 쓸 수도 있겠습니다.

## 디바운스와 쓰로틀에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/41

디바운스와 쓰로틀은 이벤트 핸들러가 너무 자주 실행되는 것을 막는 방법입니다.
디바운스는 마지막 이벤트가 발생한 후 일정 시간이 지나야 이벤트 핸들러가 실행되는 방식입니다. 예를 들어 사용자가 폼에 글자를 입력할 때마다 검색 요청을 보내면 부하가 지나치게 커지기 때문에, 사용자가 입력을 멈춘 후 일정 시간이 지나면 검색 요청을 보내는 방식입니다.
쓰로틀은 일정 시간 간격 동안 발생한 이벤트 중 첫 번째나 마지막 이벤트만 처리하는 방식입니다. 예를 들어 사용자가 버튼을 연타할 경우 클릭할 때마다 이벤트가 발생하면 부하가 지나치게 커지기 때문에, 쓰로틀을 적용해 일정 시간 동안 여러 번 연타해도 한 번만 처리하게 할 수 있습니다.

#### 디바운스와 쓰로틀 중에서 무한 스크롤 구현 시 어떤 방식을 선택하시겠습니까? 그 이유는 무엇인가요?

무한 스크롤을 하려면 사용자가 페이지 맨 밑에 스크롤을 내렸을 때 서버에 요청이 가야 하는데,
디바운스는 스크롤을 내린 후 일정 시간이 지나야 요청이 가기 때문에 부적합합니다.
쓰로틀을 사용해서 스크롤이 맨 밑으로 내려가자마자 추가 데이터 요청을 넣도록 하겠습니다.

## 브라우저의 성능 최적화를 할 수 있는 방법에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/40

우선 코드 스플리팅을 통해 자바스크립트 파일을 전부 한꺼번에 불러오는 대신 당장 필요한 부분만 먼저 로드하여 페이지 로딩 속도를 개선할 수 있습니다.
그리고 이미지나 비디오 같은 무거운 리소스에 대해서 레이지 로딩을 적용할 수도 있습니다. 사용자가 페이지를 스크롤해서 밑에 있는 이미지가 필요해지면 그때 가서 이미지를 로드하는 식으로 구현합니다. 이미지에 대해서는 이미지 최적화로 파일 크기를 줄이거나 가벼운 포맷으로 변환할 수도 있습니다.
이외에도 브라우저가 캐싱을 할 수도 있고, 불필요한 DOM 크기를 줄이거나 script 태그에 async나 defer 속성을 사용해서 비동기 로딩을 하는 방법도 있습니다.

## 이벤트 전파(event propagation)에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/39

버튼 클릭 같은 이벤트가 발생했을 때, 이벤트 전파 순서는 캡처링, 타깃, 버블링 순서입니다.
DOM 트리의 최상위 요소(document 또는 window)부터 시작하여, 이벤트가 발생한 타깃 요소(여기서는 버튼)까지 내려가며 이벤트를 탐색하는 과정을 캡처링이라고 합니다.
두 번째 타깃 단계에서는 이벤트 리스너가 타깃 요소에서 실행됩니다
세 번째 버블링 단계에서는 다시 점점 상위 요소로 이벤트가 전파됩니다.
기본적으로 이벤트 리스너는 버블링 단계에서 실행되지만, 캡처링 단계에서 실행되도록 설정할 수도 있습니다.

#### 추가질문 1: 버블링은 왜 필요한가?

이벤트 위임(Event Delegation): 상위 요소에서 한 번에 이벤트를 처리 (예를 들어 리스트의 각 메뉴를 클릭했을 때)
팝업 외부를 클릭하면 팝업이 닫히는 등의 이벤트를 처리하기에 유용합니다.

#### 추가질문 2: 이벤트 전파 멈추는 방법

`event.stopPropagation()`을 호출하면, 이벤트는 버블링 단계로 더 이상 전파되지 않습니다.
예시: 모달 바깥을 클릭하면 모달이 닫히게 했을 때, stopPropagation 안 하면 모달 내부를 클릭해도 닫힘.

## CommonJS와 ES Module의 차이점에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/38

commonJS와 ES Module은 자바스크립트에서 모듈을 불러오고 내보내는 두 가지 방식입니다.
CommonJS는 자바스크립트 초창기부터 쓰던 방식인데, 동기적으로 로드하고 트리 쉐이킹이 지원되지 않습니다. require로 모듈을 동적으로 불러올 수 있기 때문입니다.
ES Module은 ES6때 나온 새로운 모듈 시스템입니다. Promise를 기반으로 비동기적으로 작동되며, 정적 분석이 가능해 트리 쉐이킹을 할 수 있습니다.
ES Module 방식을 쓰려면 package.json에서 `"type": "module"` 을 명시해야 합니다. 최근에는 대부분 ES Module 방식을 쓰지만, 레거시 문제로 CommonJS도 여전히 사용됩니다.

#### 추가질문: 트리 쉐이킹이란?

자바스크립트 번들러(Webpack, Rollup 등)가 사용하지 않는 코드를 자동으로 제거해서 최종 번들 크기를 줄이는 최적화 기법.
트리 쉐이킹이 작동하려면 코드가 정적 구조로 작성되어 어떤 모듈이 어디서 사용될지 컴파일 시점에 알 수 있어야 한다. CommonJS는 require로 모듈을 동적으로 불러올 수 있어서 정적 분석이 어렵다.

## 자바스크립트 함수에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/33

자바스크립트의 함수는 일급 객체입니다. 값처럼 자유롭게 변수에 할당하거나, 함수에 인자 또는 리턴값으로 쓰이거나, 런타임 중에 함수가 새로 생성되는 것이 가능합니다. 그래서 고차 함수 같은 식으로도 사용될 수 있습니다. (고차 함수가 뭐죠: 다른 함수를 인자로 받거나 리턴값으로 뱉는 함수입니다. Array의 map이나 forEach 같은 함수들이 있습니다.)
그리고 자바스크립트 함수는 lexical scope를 따릅니다. 함수의 호출 위치와는 관계없이 함수가 **정의**된 위치에 따라 변수에 접근할 수 있는 scope가 결정됩니다. 그래서 클로저가 가능합니다. 클로저는 내부 함수가 외부 함수의 변수 스코프를 기억해서 함수 실행이 종료된 후에도 또 호출할 때 계속 참조할 수 있는 기능을 말합니다.
화살표 함수의 경우에는 this를 렉시컬 스코프에 바인딩하기 때문에, 콜백 함수에서 기존 함수보다 더 직관적으로 사용할 수 있습니다. 다만, 생성자 함수로는 사용할 수 없고, arguments 객체를 지원하지 않는 등의 제약이 있습니다.

## 쿠키, 세션, 웹스토리지의 차이를 설명해보세요.

쿠키는 브라우저에 저장되고, http 요청마다 서버로 전송됩니다.
세션은 서버에 저장되고, 브라우저는 세션 id를 쿠키로 저장하거나 url에 포함시켜서 서버에 전달합니다. 브라우저를 닫으면 기본적으로는 세션이 종료되지만 유효기간을 설정해서 지속되게 할 수 있습니다. 데이터가 서버에 있으므로 보안에 더 적합하지만, 대규모 사용자가 접속하면 서버 메모리를 많이 차지할 수 있습니다.
웹 스토리지는 브라우저만 저장하고 서버로 전송되지 않습니다. 로컬 스토리지는 삭제하지 않는 한 영구적으로 저장되고, 세션 스토리지는 브라우저 탭을 닫으면 삭제됩니다.

#### 추가질문: 각각 어떤 상황에서 사용하면 적절한가요?

쿠키는 클라이언트와 서버 간 상태를 유지하기 위해 사용됩니다. 예를 들어, 세션 ID나 사용자 인증 토큰을 쿠키에 저장하면 서버와의 상태를 동기화할 수 있습니다.사용자의 행동을 추적하거나 간단한 사용자 설정 등을 저장할 때도 쓰입니다.
세션은 클라이언트에 저장하면 안 되는 보안이 중요한 데이터를 저장할 때 쓰입니다. 클라이언트는 세션 ID만 저장하며, 실제 데이터는 서버에서 관리하기 때문에 민감한 정보를 안전하게 보호할 수 있습니다.
웹 스토리지는 서버 요청 없이 데이터를 활용할 때 쓰입니다. 예를 들어 비회원 장바구니 기능을 로컬스토리지에 저장해두고 주문하기를 누르면 회원가입 창으로 이동시킬 수 있습니다. 폼 입력과 같이 현재 탭을 닫으면 삭제되게 하고 싶을 때는 세션 스토리지를 씁니다.

## 자바스크립트 호이스팅에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/31

변수와 함수 선언을 제일 먼저 끌어올려서 하는 것을 호이스팅이라고 합니다. 자바스크립트에서는 변수와 함수 선언을 코드 어디에서 하더라도 최상단에서 선언한 것처럼 호이스팅이 됩니다. 그래서 함수 호출 코드가 더 위에 있고 밑에서 함수를 선언한다고 해도 문제가 없습니다. 하지만 호이스팅되는 것은 선언뿐이지 값 할당은 호이스팅되지 않습니다.
그래서 초기화 전까지 var로 선언된 변수는 undefined로 취급되는데, let과 const는 선언되었어도 초기화 전까지는 접근할 수 없습니다 - ReferenceError가 발생합니다.

### 추가질문: var, let, const의 차이를 설명해주세요.

let과 const는 var의 한계를 보완하기 위해 ES6에서부터 도입된 문법입니다.
var는 함수 스코프를 가집니다. 함수 내부에서 선언되면 그 함수 안에서만 동작하는데, 함수 외부에서 선언된 var는 전역 변수처럼 동작합니다. if문 같은 블록 안에서 선언되더라도 블록 밖에서 역시 접근 가능합니다. 반면 let과 const는 블록 스코프를 가지므로 블록 안에서 선언하면 블록 밖에서 접근할 수 없습니다.
또한 var는 같은 스코프 내에서 재선언이 가능한데 let과 const는 재선언이 불가능합니다. 값을 재할당하는 것은 var와 let에서 가능하고 const는 상수 취급되기 때문에 재할당이 불가능합니다. 다만 객체나 배열의 내부 값을 변경하는 것은 가능합니다. 주소값이 변하지 않기 때문에.
마지막으로 호이스팅 시에 var는 초기화 전에 undefined로 취급되지만 let과 const는 초기화 전에 접근하면 레퍼런스 에러가 뜹니다.
최근에는 var는 잘 쓰이지 않고, const를 주로 사용하면서 재할당이 필요한 경우에만 let을 사용하는 것을 권장합니다.

## 리액트의 render phase와 commit phase에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/30

리액트의 렌더링 과정은 크게 렌더 페이즈와 커밋 페이즈로 나눌 수 있습니다. 렌더 페이즈는 props나 state의 변화에 따라서 어떻게 UI를 변경할지를 가상 DOM에서 먼저 계산해보는 단계입니다. 이 단계는 브라우저와 독립적으로 작동하며, 작업 우선순위에 따라 비동기적으로 실행될 수 있습니다. 이렇게 계산된 내용을 커밋 페이즈에서 실제 DOM에 반영합니다.

## 인터넷 창에서 www.google.com 를 입력하면 무슨 일이 일어나는지 설명해주세요.

https://www.maeil-mail.kr/question/20

우선 DNS 조회부터 시작합니다. www google.com 이라는 도메인 이름을 브라우저가 IP 주소로 변환하기 위해서 DNS를 조회하는데요, 캐시된 DNS 기록이 있는지 먼저 확인하고 없으면 로컬 DNS 서버에 요청해서 해당 IP 주소를 얻습니다.
그 다음에 브라우저와 서버 간에 3-way 핸드셰이크로 TCP 연결을 합니다. TCP는 데이터를 신뢰성 있게 전달하기 위한 연결 프로토콜인데요, 브라우저가 먼저 SYN 패킷을 전송하고, 서버가 그걸 받아서 응답으로 SYN-ACK 패킷을 전송하고, 다시 브라우저가 응답을 받고 ACK 패킷을 보냄으로써 연결이 완료됩니다.
그러면 이제 브라우저가 GET 요청 같은 HTTP 요청을 보낼 수 있습니다. HTTPS를 사용한다면 이 단계에서 SSL-TLS 핸드셰이크를 수행함으로써 보안 인증서를 교환하고 암호화 키를 협상해서 서버의 신원을 확인하고 이후 통신이 암호화 상태로 진행될 수 있게 합니다.
서버로부터 요청에 대한 응답이 오면, 브라우저는 받은 리소스들을 바탕으로 브라우저 렌더링 파이프라인을 진행합니다.

## 브라우저 렌더링 파이프라인에 대해서 설명해주세요.

https://www.maeil-mail.kr/question/19

우선 브라우저가 서버에서 html 코드부터 바이트로 가져옵니다. 그리고 파서가 이걸 문자로 변환하고, 문자를 다시 html 토큰으로 파싱해서 DOM 트리를 만듭니다. 그 다음에 CSS도 마찬가지로 트리를 생성하고, DOM과 CSSOM을 합쳐서 렌더 트리를 생성합니다. 그 렌더 트리를 가지고 뷰포트에 따라서 레이아웃을 계산하고, 페인팅 작업에 들어갑니다. 마지막으로 페인팅된 요소들을 각각의 레이어로 분리하고, 이 레이어들을 결합해서 최종적으로 컴포지팅, 화면을 구성하게 됩니다.

## 리액트에서 성능 최적화를 위한 방법들을 설명해주세요.

https://www.maeil-mail.kr/question/18

리액트에서 성능 최적화를 하려면 첫 번째, 불필요한 리렌더링을 줄이거나, 두 번째, 코드 로딩 시간을 줄여야 합니다.
첫 번째로 불필요한 리렌더링을 줄이는 방법으로는 메모이제이션이 있습니다. 이미 계산된 결과를 저장해두고 다음에 같은 계산을 반복하는 대신 불러오는 방법인데요. 원래 리액트에서 부모 컴포넌트가 리렌더링될 때 자식도 같이 리렌더링되는데, 부모가 변경되었지만 자식에게 영향이 없는 경우도 있습니다. 자식 컴포넌트를 `React.memo`로 감싸두면 props가 변경되었는지를 확인해서 이 자식에게 오는 props가 변경되지 않았다면 리렌더링하지 않습니다. 하지만 props에 전달되는 값이 함수나 객체일 경우에는, 부모가 리렌더링될 때 새로운 함수나 객체가 생성되어 props가 변경된 것으로 인식되는 한계가 있을 수 있습니다. 그래서 props로 함수가 전달될 때는 useCallback으로 함수를 메모이제이션하고, props가 객체일 때나 아니면 긴 배열의 필터링 결과 같이 비용이 큰 계산을 메모이제이션해야할 때는 useMemo를 사용합니다.
다만 메모이제이션에도 비용이 들고, 리액트도 더 효율적인 리렌더링 방식으로 업데이트되고 있기 때문에 많이 복잡한 계산이 아니면 오히려 성능이 악화될 수도 있어 꼭 필요할 때만 쓰는 게 좋습니다 .
두 번째로 코드 스플리팅을 통해 코드 로딩 시간을 줄일 수 있습니다. 앱이 커서 초기 로딩 속도가 느리거나 페이지별로 필요한 코드가 다를 때, `React.lazy`를 써서 특정 컴포넌트는 필요할 때가 되면 불러오도록 할 수 있습니다.
