1. [리액트에서 성능 최적화를 위한 방법들을 설명해주세요](#리액트에서-성능-최적화를-위한-방법들을-설명해주세요)
2. [그럼 코드 스플리팅은 어떤 경우에 사용해야할까요?](#그럼-코드-스플리팅은-어떤-경우에-사용해야할까요)
3. [React의 Suspense와 Concurrent Mode의 개념을 설명하고, 이를 사용하여 애플리케이션 성능을 최적화할 수 있는 방법을 설명해 주세요](#react의-suspense와-concurrent-mode의-개념을-설명하고-이를-사용하여-애플리케이션-성능을-최적화할-수-있는-방법을-설명해-주세요)
4. [브라우저 렌더링 파이프라인에 대해서 설명해주세요](#브라우저-렌더링-파이프라인에-대해서-설명해주세요)
5. [리플로우와 리페인트 최소화 방법](#리플로우와-리페인트-최소화-방법)
6. [인터넷 창에서 www.google.com을 입력하면 무슨 일이 일어나는지 설명해주세요](#인터넷-창에서-wwwgooglecom을-입력하면-무슨-일이-일어나는지-설명해주세요)
7. [리액트의 render phase와 commit phase에 대해서 설명해주세요](#리액트의-render-phase와-commit-phase에-대해서-설명해주세요)
8. [그럼 render phase와 commit phase는 어떻게 동기화되나요?](#그럼-render-phase와-commit-phase는-어떻게-동기화되나요)
9. [자바스크립트 호이스팅에 대해서 설명해주세요](#자바스크립트-호이스팅에-대해서-설명해주세요)
10. [쿠키, 세션, 웹스토리지의 차이를 설명해보세요](#쿠키,-세션,-웹스토리지의-차이를-설명해보세요)
11. [자바스크립트 함수에 대해서 설명해주세요](#자바스크립트-함수에-대해서-설명해주세요)
12. [CommonJS와 ES Module의 차이점에 대해서 설명해주세요.](#CommonJS와-ES-Module의-차이점에-대해서-설명해주세요.)
13. [이벤트 전파(event propagation)에 대해서 설명해주세요.](#이벤트-전파(event-propagation)에-대해서-설명해주세요.)

---
### 리액트에서 성능 최적화를 위한 방법들을 설명해주세요
리액트 성능 최적화 방법 중 대표적으로 메모이제이션이 있습니다. 리액트 memo는 컴포넌트 props가 변경되지 않았을 때, 리렌더링을 방지하여 성능을 최적화합니다.  
또한 useCallback 과 useMemo를 활용할 수도 있습니다. useCallback은 함수를 메모이제이션하여 불필요한 함수 재생성을 방지합니다. useMemo는 값을 재계산 하는 것을 방지하여 성능을 최적화합니다. 이를 통해 자식 컴포넌트로 전달되는 함수나 값이 변경되지 않으면 리렌더링을 피할 수 있습니다.
마지막으로 코드 스플리팅을 활용해볼 수 있습니다. 코드 스플리팅은 큰 애플리케이션을 여러 개의 작은 청크로 나누어, 필요한 청크만 로드해서 초기 로드 시간을 줄입니다. [리액트는 SPA의 기본 구조로 되어있기 때문에 페이지별로 분리된 코드가 없다면, 모든 코드가 처음 로드될 때 한꺼번에 로드됩니다. 이 경우] React.lazy와 Suspense를 사용하여 동적으로 컴포넌트를 로드하고, 필요한 코드만 로드하여 초기 로드 시간을 개선할 수 있습니다.
### 그럼 코드 스플리팅은 어떤 경우에 사용해야할까요?
첫번째로 초기 로딩시간이 길어지는 경우입니다. 코드 스플리팅을 사용해 초기 로드 시 필요한 코드만 로드하고, 이후 추가적인 기능은 필요할 때 로드하도록 하면 초기 로딩 속도를 개선할 수 있습니다.  
두번째로 라우트별 코드 분할이 필요한 경우입니다. SPA에서는 각 페이지가 별도의 기능과 UI를 가지므로, 라우트별로 필요한 코드만 분리하여 로드할 수 있습니다. 이 방식은 리액트의 React.lasy와 Suspense를 사용해 라우트별 컴포넌트를 동적으로 불러올 때 유용합니다.
### [React의 Suspense와 Concurrent Mode의 개념을 설명하고, 이를 사용하여 애플리케이션 성능을 최적화할 수 있는 방법을 설명해 주세요.]
React의 Suspense는 컴포넌트가 비동기적으로 데이터를 로드하거나 동적으로 로드될 때, 해당 컴포넌트가 준비될 때까지 기다리며 대체 UI를 제공하는 기능입니다. 주로 React.lazy와 함께 사용되어, 동적으로 로드되는 컴포넌트를 보여줄 때까지 로딩 UI를 사용자에게 표시합니다. 이를 통해 비동기 로딩 상태에서 빈 화면을 보여주는 대신, 로딩 UI를 표시해 사용자 경험을 개선할 수 있습니다.
Concurrent Mode는 React의 렌더링 모드로, 여러 작업을 병렬로 처리하여 애플리케이션의 응답성을 향상시키는 기능입니다. 이 모드는 React가 UI 업데이트를 우선순위에 따라 효율적으로 처리할 수 있도록 돕습니다. 예를 들어, useTransition 훅을 사용하면 사용자 입력과 관련된 중요한 작업을 먼저 처리하고, 덜 중요한 작업은 나중에 처리할 수 있게 되어, 사용자 상호작용에 즉각적으로 반응할 수 있습니다.

### 브라우저 렌더링 파이프라인에 대해서 설명해주세요
브라우저가 웹 페이지를 화면에 표시하는 과정을 브라우저 렌더링 파이프라인이라고 합니다. 이 과정은 크게 6가지로 나뉩니다.  
첫번째로 DOM 생성입니다.  
브라우저는 HTML 파일을 파싱하여 DOM 트리를 생성합니다. DOM 트리는 HTML 문서 구조를 계층적으로 표현한 것입니다.  
두번째로 CSSOM 생성입니다.  
브라우저는 CSS파일을 파싱하여 CSSOM 트리를 생성합니다. 이 트리는 스타일 규칙과 HTML 요소를 연결하여 각 요소에 적용될 스타일을 결정합니다.  
세번째로 렌더 트리 생성입니다.  
이제 브라우저는 DOM과 CSSOM을 결합하여 렌더 트리를 생성합니다. 렌더 트리는 화면에 실제로 표시될 요소들로만 구성됩니다.  
네번째로 레이아웃입니다.  
렌더 트리가 생성된 후, 브라우저는 이 트리를 사용해 각 요소의 위치와 크기를 계산하는 레이아웃 과정을 수행합니다.  
화면의 크기가 변경되면 브라우저는 레이아웃을 다시 수행하게 되는데, 이를 리플로우라 합니다. 리플로우는 성능에 영향을 줄 수 있어 최소화하는 것이 중요합니다.  
다섯번째로 페인팅입니다.  
레이아웃이 완료되면, 브라우저는 각 요소를 실제 화면에 그리는 페인팅 작업을 시작합니다. 이 단계에서는 텍스트, 색상, 그림자 같은 모든 시각적 요소가 화면에 그려집니다. 요소의 위치나 크기가 변하지 않는 스타일 속성이 변경될 때 리페인트가 발생합니다. [리페인트는 리플로우보다 비용이 덜 드는 작업이지만, 여전히 성능에 영향을 줄 수 있습니다.]
마지막 단계는 컴포지팅입니다.  
브라우저는 화면에 그려질 요소들을 개별 레이어로 분리하고, 이 레이어들을 결합하여 최종 화면을 구성합니다. [이 과정에서 GPU를 활용하여 각 레이어를 빠르게 합성합니다.]  
### [리플로우와 리페인트 최소화 방법]
리플로우와 리페인트를 유발하지 않는 CSS 속성을 활용하여 애니메이션이나 스타일 변경을 수행하는 것이 좋습니다. 예를 들어, transform이나 opacity를 사용하면 레이아웃이 변경되지 않으므로 리플로우와 리페인트가 발생하지 않고, 컴포지팅 단계에서만 처리됩니다.
반면 width나 margin과 같은 속성은 리플로우를 트리거할 가능성이 높기 때문에 초기 스타일 선언 시에만 설정하는 것이 효율적입니다.  

### 인터넷 창에서 www.google.com를 입력하면 무슨 일이 일어나는지 설명해주세요
먼저 사용자가 주소를 입력하면, 브라우저는 이 도메인 이름을 IP 주소로 변환해야 합니다. 이 과정을 DNS Lookup(조회)라고 합니다. 브라우저는 캐시된 DNS 기록을 먼저 확인하고, 없다면 로컬 DNS 서버에 요청하여 도메인에 해당하는 IP 주소를 얻습니다.
IP 주소가 확인되면, 브라우저는 서버와 TCP 연결을 수립합니다. TCP는 데이터를 신뢰성 있게 전달하기 위한 프로토콜입니다. 이 과정에서 브라우저는 서버와 3-way-handshake를 수행합니다. [즉, 브라우저가 SYN 패킷을 보내고, 서버가 SYN-ACK패킷을 보내며, 다시 브라우저가 ACK 패킷을 보내는 과정입니다.]
TCP 연결이 완료되면, 브라우저는 HTTP또는 HTTPS 요청을 보냅니다. 이 요청은 웹 페이지를 리소스를 요청하는 메세지입니다. HTTPS를 사용할 경우, 이 단계에서 SSL/TLS 핸드셰이크도 수행됩니다.  
서버는 요청을 받고, 해당 리소스를 브라우저에게 응답 보냅니다.  
마지막으로 받은 리소스들을 바탕으로 브라우저 렌더링 파이프라인을 진행합니다. DOM과 CSSOM을 생성하고, 렌더 트리를 구성한 뒤, 레이아웃과 페인트 단계를 통해 웹 페이지가 화면에 표시됩니다.  

### 리액트의 render phase와 commit phase에 대해서 설명해주세요
리액트의 렌더링 과정은 두 가지로 나눌 수 있습니다.

먼저 render phase는 리액트가 변화된 상태나 props에 따라 어떤 UI가 변경되어야 할지를 결정하는 단계입니다. 이 과정에서는 실제로 DOM을 업데이트하지 않고, 변경사항을 가상 DOM에서 계산하여 비교합니다. 이 단계는 순수하게 계산과정이기 때문에 성능에 영향을 주지 않도록 중단되거나 다시 실행될 수 있으며, React 18에서 도입된 Coneurrent Mode를 통해 비동기적으로 처리될 수도 있습니다.

다음으로 commit phase는 실제 변화된 UI를 DOM에 반영하는 단계입니다. 이때 리액트는 가상 DOM에서 계산된 결과를 실제 DOM에 적용하고, 변화된 UI를 브라우저에 렌더링합니다. 이 과정에서 useEffect와 같은 사이드 이펙트가 발생하는 훅들이 실행됩니다.

[정리하자면 render phase는 변화된 UI를 결정하는 과정이고, commit phase는 그 결정된 결과를 실제로 반영하는 단계입니다.]

![image](https://github.com/user-attachments/assets/b873017c-a28a-47e4-a51d-25c314a57f06)


### [그럼 render phase와 commit phase는 어떻게 동기화되나요?]

두가지의 단계로 말씀드릴 수 있습니다. 단계적 진행과 병목 관리입니다. 첫번째로 render phase가 완료되면 리액트는 즉시 commit하지 않고, 다른 높은 우선순위 작업이 있다면 먼저 처리한 후 나중에 commit phase를 실행할 수 있습니다. 이를 통해 React는 동기화가 필요한 작업을 효율적으로 관리합니다.

두번째로 병목 관리입니다. render phase에서 모든 변경 사항이 Fiber Tree에 준비된 상태에서 commit phase로 넘어가므로, render와 commit 단계의 일관성이 유지됩니다. 이렇게 두 단계는 순차적으로 작동하여, UI가 정확하게 동기화되고 불필요한 재렌더링을 방지합니다.


### 자바스크립트 호이스팅에 대해서 설명해주세요

호이스팅은 자바스크립트가 코드를 실행하기 전에 변수와 함수 선언을 코드의 최상단으로 끌어올리는 것처럼 동작하는 특징입니다. 이를 통해 코드 선언 위치와 관계 없이 변수를 사용할 수 있는 것처럼 보일 수 있습니다.  
하지만 호이스팅은 선언의 호이스팅일 뿐, 변수의 값 할당까지 끌어올려지지는 않습니다.  
예를 들어 var로 선언된 변수는 호이스팅 되지만, undefined로 평가됩니다.  
함수의 경우 함수 전체가 호이스팅되기 때문에 호출 이후에 선언해도 문제가 없습니다.  

그러나 ES6에 도입된 let과 const는 호이스팅이 되긴 하지만, 선언 전에 접근하면 ReferenceError가 발생합니다.  
이는 TDZ(Temporal Dead Zone)이라는 개념 때문인데요. TDZ는 변수가 선언되었지만 초기화되기 전가지의 구간을 말합니다. let과 const로 선언된 변수는 TDZ가 존재하며, 이 구간에서는 변수에 접근할 수 없습니다.


### 쿠키, 세션, 웹스토리지의 차이를 설명해보세요

먼저 쿠키는 서버와 클라이언트 데이터 교환에 사용됩니다. 키-값 쌍으로 저장되며 유효기간을 설정할 수 있습니다.  
세션은 서버에 데이터가 저장되며 클라이언트는 세션 ID만 저장합니다. 서버에서 관리되기 때문에 클라이언트에서는 데이터를 조작할 수 없습니다. 세션은 브라우저를 닫으면 만료됩니다.  
웹 스토리지는 브라우저 내부에서 데이터를 저장하며 브라우저를 닫아도 데이터가 삭제되지 않습니다. 쿠키와 동일하게 키-값 쌍으로 저장되며 데이터 교환 시 서버로 전송되지 않습니다.

### 자바스크립트 함수에 대해서 설명해주세요

자바스크립트 함수는 일급 객체로써 다뤄지며 클로저, 고차 함수, 화살표 함수 등의 기능들을 제공합니다.  
일급 객체의 특징은 자바스크립트 함수가 변수에 할당되거나, 다른 함수의 인자로 전달되거나, 함수에서 반환될 수 있다는 점입니다.  
또한 자바스크립트 함수는 함수의 이름이 없는 익명함수로 사용될 수 있으며, 변수에 값처럼 담는 함수 표현식으로도 사용할 수 있습니다.  
함수 선언은 코드가 실행되기 전에 호이스팅되어, 함수선언 이전에 호출할 수 있습니다.  
자바스크립트 함수는 클로저 기능도 제공합니다. 클로저는 함수가 자신이 선언된 환경, 즉 스코프를 기억하고 그 외부 스코프에 접근할 수 있는 기능입니다. 이를 통해 함수는 자신이 선언된 스코프 내의 변수를 참조하고 유지할 수 있습니다.  
마지막으로 고차함수 입니다. 자바스크립트에서는 함수가 일급 객체이기 때문에 다른 함수를 인자로 받거나 반환하는 고차함수를 정의할 수 있습니다.  

### CommonJS와 ES Module의 차이점에 대해서 설명해주세요.

**CommonJS**와 **ES Module(ESM)** 은 자바스크립트에서 모듈을 관리하고 불러오는 방식입니다.  
**CommonJS**는 Node.js 환경에서 사용되며, 모듈을 동기적으로 불러옵니다. 주로 서버측에서 많이 사용됩니다.  
**ES Module(ESM)**은 자바스크립트 표준 모듈 시스템으로 ESM은 브라우저와 Node.js 환경에서 모두 사용할 수 있으며, 비동기적으로 로드합니다. 또한 ESM은 정적 분석이 가능해, 트리 쉐이킹과 같은 최적화 작업에도 유리합니다. ESM은 브라우저와 서버 모두에서 사용할 수 있습니다.

### 이벤트 전파(event propagation)에 대해서 설명해주세요.

이벤트 전파는 DOM에서 이벤트가 발생했을 때 그 이벤트가 어떤 방식으로 전파되는지 설명하는 개념입니다. 크게 캡처링, 타겟, 버블링이 있습니다.

먼저 캡처링은 이벤트가 DOM 트리의 최상위 요소에서 시작하여, 이벤트 발생 요소로 내려가는 단계입니다. 이 과정에서 상위 요소들에 이벤트 리스너가 있으면 그 순서대로 실행될 수 있습니다.

다음은 타겟 단계입니다. 이벤트가 실제 발생한 타겟 요소에 도달하는 단계입니다. 타겟 요소에 등록된 이벤트 리스너가 이 시점에 실행됩니다.

마지막 버블링 단계입니다. 타겟 요소에서 이벤트가 발생한 후, 다시 DOM 트리의 상위 요소들러 전파되어 올라가는 단계입니다. 이 과정에서 상위 요소들에 등록된 이벤트 리스너들이 실행될 수 있습니다.

이벤트 전파는 event.stopPropagation 메서드를 사용해 중단할 수도 있으며 capture:true로 설정하여 캡처링 단계에서 이벤트를 처리할 수 있습니다.
