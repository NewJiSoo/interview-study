### 리액트에서 성능 최적화를 위한 방법들을 설명해주세요.
리액트 성능 최적화 방법 중 대표적으로 메모이제이션이 있습니다. 리액트 memo는 컴포넌트 props가 변경되지 않았을 때, 리렌더링을 방지하여 성능을 최적화합니다.  
또한 useCallback 과 useMemo를 활용할 수도 있습니다. useCallback은 함수를 메모이제이션하여 불필요한 함수 재생성을 방지합니다. useMemo는 값을 재계산 하는 것을 방지하여 성능을 최적화합니다. 이를 통해 자식 컴포넌트로 전달되는 함수나 값이 변경되지 않으면 리렌더링을 피할 수 있습니다.
마지막으로 코드 스플리팅을 활용해볼 수 있습니다. 코드 스플리팅은 큰 애플리케이션을 여러 개의 작은 청크로 나누어, 필요한 청크만 로드해서 초기 로드 시간을 줄입니다. [리액트는 SPA의 기본 구조로 되어있기 때문에 페이지별로 분리된 코드가 없다면, 모든 코드가 처음 로드될 때 한꺼번에 로드됩니다. 이 경우] React.lazy와 Suspense를 사용하여 동적으로 컴포넌트를 로드하고, 필요한 코드만 로드하여 초기 로드 시간을 개선할 수 있습니다.
### 그럼 코드 스플리팅은 어떤 경우에 사용해야할까요?
첫번째로 초기 로딩시간이 길어지는 경우입니다. 코드 스플리팅을 사용해 초기 로드 시 필요한 코드만 로드하고, 이후 추가적인 기능은 필요할 때 로드하도록 하면 초기 로딩 속도를 개선할 수 있습니다.  
두번째로 라우트별 코드 분할이 필요한 경우입니다. SPA에서는 각 페이지가 별도의 기능과 UI를 가지므로, 라우트별로 필요한 코드만 분리하여 로드할 수 있습니다. 이 방식은 리액트의 React.lasy와 Suspense를 사용해 라우트별 컴포넌트를 동적으로 불러올 때 유용합니다.
### [React의 Suspense와 Concurrent Mode의 개념을 설명하고, 이를 사용하여 애플리케이션 성능을 최적화할 수 있는 방법을 설명해 주세요.]
React의 Suspense는 컴포넌트가 비동기적으로 데이터를 로드하거나 동적으로 로드될 때, 해당 컴포넌트가 준비될 때까지 기다리며 대체 UI를 제공하는 기능입니다. 주로 React.lazy와 함께 사용되어, 동적으로 로드되는 컴포넌트를 보여줄 때까지 로딩 UI를 사용자에게 표시합니다. 이를 통해 비동기 로딩 상태에서 빈 화면을 보여주는 대신, 로딩 UI를 표시해 사용자 경험을 개선할 수 있습니다.
Concurrent Mode는 React의 렌더링 모드로, 여러 작업을 병렬로 처리하여 애플리케이션의 응답성을 향상시키는 기능입니다. 이 모드는 React가 UI 업데이트를 우선순위에 따라 효율적으로 처리할 수 있도록 돕습니다. 예를 들어, useTransition 훅을 사용하면 사용자 입력과 관련된 중요한 작업을 먼저 처리하고, 덜 중요한 작업은 나중에 처리할 수 있게 되어, 사용자 상호작용에 즉각적으로 반응할 수 있습니다.

### 브라우저 렌더링 파이프라인에 대해서 설명해주세요.
브라우저가 웹 페이지를 화면에 표시하는 과정을 브라우저 렌더링 파이프라인이라고 합니다. 이 과정은 크게 6가지로 나뉩니다.  
첫번째로 DOM 생성입니다.  
브라우저는 HTML 파일을 파싱하여 DOM 트리를 생성합니다. DOM 트리는 HTML 문서 구조를 계층적으로 표현한 것입니다.  
두번째로 CSSOM 생성입니다.  
브라우저는 CSS파일을 파싱하여 CSSOM 트리를 생성합니다. 이 트리는 스타일 규칙과 HTML 요소를 연결하여 각 요소에 적용될 스타일을 결정합니다.  
세번째로 렌더 트리 생성입니다.  
이제 브라우저는 DOM과 CSSOM을 결합하여 렌더 트리를 생성합니다. 렌더 트리는 화면에 실제로 표시될 요소들로만 구성됩니다.  
네번째로 레이아웃입니다.  
렌더 트리가 생성된 후, 브라우저는 이 트리를 사용해 각 요소의 위치와 크기를 계산하는 레이아웃 과정을 수행합니다.  
화면의 크기가 변경되면 브라우저는 레이아웃을 다시 수행하게 되는데, 이를 리플로우라 합니다. 리플로우는 성능에 영향을 줄 수 있어 최소화하는 것이 중요합니다.  
다섯번째로 페인팅입니다.  
레이아웃이 완료되면, 브라우저는 각 요소를 실제 화면에 그리는 페인팅 작업을 시작합니다. 이 단계에서는 텍스트, 색상, 그림자 같은 모든 시각적 요소가 화면에 그려집니다. 요소의 위치나 크기가 변하지 않는 스타일 속성이 변경될 때 리페인트가 발생합니다. [리페인트는 리플로우보다 비용이 덜 드는 작업이지만, 여전히 성능에 영향을 줄 수 있습니다.]
마지막 단계는 컴포지팅입니다.  
브라우저는 화면에 그려질 요소들을 개별 레이어로 분리하고, 이 레이어들을 결합하여 최종 화면을 구성합니다. [이 과정에서 GPU를 활용하여 각 레이어를 빠르게 합성합니다.]  
### [리플로우와 리페인트 최소화 방법]
리플로우와 리페인트를 유발하지 않는 CSS 속성을 활용하여 애니메이션이나 스타일 변경을 수행하는 것이 좋습니다. 예를 들어, transform이나 opacity를 사용하면 레이아웃이 변경되지 않으므로 리플로우와 리페인트가 발생하지 않고, 컴포지팅 단계에서만 처리됩니다.
반면 width나 margin과 같은 속성은 리플로우를 트리거할 가능성이 높기 때문에 초기 스타일 선언 시에만 설정하는 것이 효율적입니다.  

### 인터넷 창에서 www.google.com를 입력하면 무슨 일이 일어나는지 설명해주세요.
먼저 사용자가 주소를 입력하면, 브라우저는 이 도메인 이름을 IP 주소로 변환해야 합니다. 이 과정을 DNS Lookup(조회)라고 합니다. 브라우저는 캐시된 DNS 기록을 먼저 확인하고, 없다면 로컬 DNS 서버에 요청하여 도메인에 해당하는 IP 주소를 얻습니다.
IP 주소가 확인되면, 브라우저는 서버와 TCP 연결을 수립합니다. TCP는 데이터를 신뢰성 있게 전달하기 위한 프로토콜입니다. 이 과정에서 브라우저는 서버와 3-way-handshake를 수행합니다. [즉, 브라우저가 SYN 패킷을 보내고, 서버가 SYN-ACK패킷을 보내며, 다시 브라우저가 ACK 패킷을 보내는 과정입니다.]
TCP 연결이 완료되면, 브라우저는 HTTP또는 HTTPS 요청을 보냅니다. 이 요청은 웹 페이지를 리소스를 요청하는 메세지입니다. HTTPS를 사용할 경우, 이 단계에서 SSL/TLS 핸드셰이크도 수행됩니다.  
서버는 요청을 받고, 해당 리소스를 브라우저에게 응답 보냅니다.  
마지막으로 받은 리소스들을 바탕으로 브라우저 렌더링 파이프라인을 진행합니다. DOM과 CSSOM을 생성하고, 렌더 트리를 구성한 뒤, 레이아웃과 페인트 단계를 통해 웹 페이지가 화면에 표시됩니다.  

### 리액트의 render phase와 commit phase에 대해서 설명해주세요
리액트의 렌더링 과정은 두 가지로 나눌 수 있습니다.

먼저 render phase는 리액트가 변화된 상태나 props에 따라 어떤 UI가 변경되어야 할지를 결정하는 단계입니다. 이 과정에서는 실제로 DOM을 업데이트하지 않고, 변경사항을 가상 DOM에서 계산하여 비교합니다. 이 단계는 순수하게 계산과정이기 때문에 성능에 영향을 주지 않도록 중단되거나 다시 실행될 수 있으며, React 18에서 도입된 Coneurrent Mode를 통해 비동기적으로 처리될 수도 있습니다.

다음으로 commit phase는 실제 변화된 UI를 DOM에 반영하는 단계입니다. 이때 리액트는 가상 DOM에서 계산된 결과를 실제 DOM에 적용하고, 변화된 UI를 브라우저에 렌더링합니다. 이 과정에서 useEffect와 같은 사이드 이펙트가 발생하는 훅들이 실행됩니다.

[정리하자면 render phase는 변화된 UI를 결정하는 과정이고, commit phase는 그 결정된 결과를 실제로 반영하는 단계입니다.]

![image](https://github.com/user-attachments/assets/b873017c-a28a-47e4-a51d-25c314a57f06)


### [그럼 render phase와 commit phase는 어떻게 동기화되나요?]

두가지의 단계로 말씀드릴 수 있습니다. 단계적 진행과 병목 관리입니다. 첫번째로 render phase가 완료되면 리액트는 즉시 commit하지 않고, 다른 높은 우선순위 작업이 있다면 먼저 처리한 후 나중에 commit phase를 실행할 수 있습니다. 이를 통해 React는 동기화가 필요한 작업을 효율적으로 관리합니다.

두번째로 병목 관리입니다. render phase에서 모든 변경 사항이 Fiber Tree에 준비된 상태에서 commit phase로 넘어가므로, render와 commit 단계의 일관성이 유지됩니다. 이렇게 두 단계는 순차적으로 작동하여, UI가 정확하게 동기화되고 불필요한 재렌더링을 방지합니다.

### 자바스크립트 호이스팅에 대해서 설명해주세요.
호이스팅은 자바스크립트가 코드를 실행하기 전에 변수와 함수 선언을 코드의 최상단으로 끌어올리는 것처럼 동작하는 특징입니다. 이를 통해 코드 선언 위치와 관계 없이 변수를 사용할 수 있는 것처럼 보일 수 있습니다.  
하지만 호이스팅은 선언의 호이스팅일 뿐, 변수의 값 할당까지 끌어올려지지는 않습니다.  
예를 들어 var로 선언된 변수는 호이스팅 되지만, undefined로 평가됩니다.  
함수의 경우 함수 전체가 호이스팅되기 때문에 호출 이후에 선언해도 문제가 없습니다.  

그러나 ES6에 도입된 let과 const는 호이스팅이 되긴 하지만, 선언 전에 접근하면 ReferenceError가 발생합니다.  
이는 TDZ(Temporal Dead Zone)이라는 개념 때문인데요. TDZ는 변수가 선언되었지만 초기화되기 전가지의 구간을 말합니다. let과 const로 선언된 변수는 TDZ가 존재하며, 이 구간에서는 변수에 접근할 수 없습니다.
