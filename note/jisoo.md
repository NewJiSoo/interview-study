1. [리액트에서 성능 최적화를 위한 방법들을 설명해주세요](#리액트에서-성능-최적화를-위한-방법들을-설명해주세요)
2. [그럼 코드 스플리팅은 어떤 경우에 사용해야할까요?](#그럼-코드-스플리팅은-어떤-경우에-사용해야할까요)
3. [React의 Suspense와 Concurrent Mode의 개념을 설명하고, 이를 사용하여 애플리케이션 성능을 최적화할 수 있는 방법을 설명해 주세요](#react의-suspense와-concurrent-mode의-개념을-설명하고-이를-사용하여-애플리케이션-성능을-최적화할-수-있는-방법을-설명해-주세요)
4. [브라우저 렌더링 파이프라인에 대해서 설명해주세요](#브라우저-렌더링-파이프라인에-대해서-설명해주세요)
5. [리플로우와 리페인트 최소화 방법](#리플로우와-리페인트-최소화-방법)
6. [인터넷 창에서 www.google.com을 입력하면 무슨 일이 일어나는지 설명해주세요](#인터넷-창에서-wwwgooglecom을-입력하면-무슨-일이-일어나는지-설명해주세요)
7. [리액트의 render phase와 commit phase에 대해서 설명해주세요](#리액트의-render-phase와-commit-phase에-대해서-설명해주세요)
8. [그럼 render phase와 commit phase는 어떻게 동기화되나요?](#그럼-render-phase와-commit-phase는-어떻게-동기화되나요)
9. [자바스크립트 호이스팅에 대해서 설명해주세요](#자바스크립트-호이스팅에-대해서-설명해주세요)
10. [쿠키, 세션, 웹스토리지의 차이를 설명해보세요](#쿠키,-세션,-웹스토리지의-차이를-설명해보세요)
11. [자바스크립트 함수에 대해서 설명해주세요](#자바스크립트-함수에-대해서-설명해주세요)
12. [CommonJS와 ES Module의 차이점에 대해서 설명해주세요](#CommonJS와-ES-Module의-차이점에-대해서-설명해주세요)
13. [브라우저의 성능 최적화를 할 수 있는 방법에 대해서 설명해주세요](#브라우저의-성능-최적화를-할-수-있는-방법에-대해서-설명해주세요)
14. [디바운스와 쓰로틀에 대해서 설명해주세요](#디바운스와-쓰로틀에-대해서-설명해주세요)
15. [리액트에서 index를 key값으로 사용하면 안되는 이유에 대해서 설명해주세요](#리액트에서-index를-key값으로-사용하면-안되는-이유에-대해서-설명해주세요)
16. [async/await에 대해 설명해보세요](#async/await에-대해-설명해보세요)
17. [useEffect와 useLayoutEffect의 차이점에 대해서 설명해주세요](#useEffect와-useLayoutEffect의-차이점에-대해서-설명해주세요)
18. [웹 접근성의 개념과 개선 방법에 대해 설명해주세요](#웹-접근성의-개념과-개선-방법에-대해-설명해주세요)
19. [SSR(Server Side Rendering)에 대해 설명해주세요](#SSR(Server-Side-Rendering)에-대해-설명해주세요)
20. [CSS Flexbox와 Grid의 차이점에 대해서 설명해주세요](#CSS-Flexbox와-Grid의-차이점에-대해서-설명해주세요)
21. [프론트엔드 E2E 테스트에 대해서 설명해주세요](#프론트엔드-E2E-테스트에-대해서-설명해주세요)
22. [이미지 크기가 클 경우 렌더링 속도가 느려질 텐데, 이를 개선하기 위한 방법들을 설명해주세요](#이미지-크기가-클-경우-렌더링-속도가-느려질-텐데,-이를-개선하기-위한-방법들을-설명해주세요)
23. [자바스크립트는 싱글 스레드 언어인데, 어떻게 동시에 여러 작업들을 수행하나요?](#자바스크립트는-싱글-스레드-언어인데,-어떻게-동시에-여러-작업들을-수행하나요?)


---
### 리액트에서 성능 최적화를 위한 방법들을 설명해주세요
리액트 성능 최적화 방법 중 대표적으로 메모이제이션이 있습니다. 리액트 memo는 컴포넌트 props가 변경되지 않았을 때, 리렌더링을 방지하여 성능을 최적화합니다.  
또한 useCallback 과 useMemo를 활용할 수도 있습니다. useCallback은 함수를 메모이제이션하여 불필요한 함수 재생성을 방지합니다. useMemo는 값을 재계산 하는 것을 방지하여 성능을 최적화합니다. 이를 통해 자식 컴포넌트로 전달되는 함수나 값이 변경되지 않으면 리렌더링을 피할 수 있습니다.
마지막으로 코드 스플리팅을 활용해볼 수 있습니다. 코드 스플리팅은 큰 애플리케이션을 여러 개의 작은 청크로 나누어, 필요한 청크만 로드해서 초기 로드 시간을 줄입니다. [리액트는 SPA의 기본 구조로 되어있기 때문에 페이지별로 분리된 코드가 없다면, 모든 코드가 처음 로드될 때 한꺼번에 로드됩니다. 이 경우] React.lazy와 Suspense를 사용하여 동적으로 컴포넌트를 로드하고, 필요한 코드만 로드하여 초기 로드 시간을 개선할 수 있습니다.
### 그럼 코드 스플리팅은 어떤 경우에 사용해야할까요?
첫번째로 초기 로딩시간이 길어지는 경우입니다. 코드 스플리팅을 사용해 초기 로드 시 필요한 코드만 로드하고, 이후 추가적인 기능은 필요할 때 로드하도록 하면 초기 로딩 속도를 개선할 수 있습니다.  
두번째로 라우트별 코드 분할이 필요한 경우입니다. SPA에서는 각 페이지가 별도의 기능과 UI를 가지므로, 라우트별로 필요한 코드만 분리하여 로드할 수 있습니다. 이 방식은 리액트의 React.lasy와 Suspense를 사용해 라우트별 컴포넌트를 동적으로 불러올 때 유용합니다.
### [React의 Suspense와 Concurrent Mode의 개념을 설명하고, 이를 사용하여 애플리케이션 성능을 최적화할 수 있는 방법을 설명해 주세요.]
React의 Suspense는 컴포넌트가 비동기적으로 데이터를 로드하거나 동적으로 로드될 때, 해당 컴포넌트가 준비될 때까지 기다리며 대체 UI를 제공하는 기능입니다. 주로 React.lazy와 함께 사용되어, 동적으로 로드되는 컴포넌트를 보여줄 때까지 로딩 UI를 사용자에게 표시합니다. 이를 통해 비동기 로딩 상태에서 빈 화면을 보여주는 대신, 로딩 UI를 표시해 사용자 경험을 개선할 수 있습니다.
Concurrent Mode는 React의 렌더링 모드로, 여러 작업을 병렬로 처리하여 애플리케이션의 응답성을 향상시키는 기능입니다. 이 모드는 React가 UI 업데이트를 우선순위에 따라 효율적으로 처리할 수 있도록 돕습니다. 예를 들어, useTransition 훅을 사용하면 사용자 입력과 관련된 중요한 작업을 먼저 처리하고, 덜 중요한 작업은 나중에 처리할 수 있게 되어, 사용자 상호작용에 즉각적으로 반응할 수 있습니다.

### 브라우저 렌더링 파이프라인에 대해서 설명해주세요
브라우저가 웹 페이지를 화면에 표시하는 과정을 브라우저 렌더링 파이프라인이라고 합니다. 이 과정은 크게 6가지로 나뉩니다.  
첫번째로 DOM 생성입니다.  
브라우저는 HTML 파일을 파싱하여 DOM 트리를 생성합니다. DOM 트리는 HTML 문서 구조를 계층적으로 표현한 것입니다.  
두번째로 CSSOM 생성입니다.  
브라우저는 CSS파일을 파싱하여 CSSOM 트리를 생성합니다. 이 트리는 스타일 규칙과 HTML 요소를 연결하여 각 요소에 적용될 스타일을 결정합니다.  
세번째로 렌더 트리 생성입니다.  
이제 브라우저는 DOM과 CSSOM을 결합하여 렌더 트리를 생성합니다. 렌더 트리는 화면에 실제로 표시될 요소들로만 구성됩니다.  
네번째로 레이아웃입니다.  
렌더 트리가 생성된 후, 브라우저는 이 트리를 사용해 각 요소의 위치와 크기를 계산하는 레이아웃 과정을 수행합니다.  
화면의 크기가 변경되면 브라우저는 레이아웃을 다시 수행하게 되는데, 이를 리플로우라 합니다. 리플로우는 성능에 영향을 줄 수 있어 최소화하는 것이 중요합니다.  
다섯번째로 페인팅입니다.  
레이아웃이 완료되면, 브라우저는 각 요소를 실제 화면에 그리는 페인팅 작업을 시작합니다. 이 단계에서는 텍스트, 색상, 그림자 같은 모든 시각적 요소가 화면에 그려집니다. 요소의 위치나 크기가 변하지 않는 스타일 속성이 변경될 때 리페인트가 발생합니다. [리페인트는 리플로우보다 비용이 덜 드는 작업이지만, 여전히 성능에 영향을 줄 수 있습니다.]
마지막 단계는 컴포지팅입니다.  
브라우저는 화면에 그려질 요소들을 개별 레이어로 분리하고, 이 레이어들을 결합하여 최종 화면을 구성합니다. [이 과정에서 GPU를 활용하여 각 레이어를 빠르게 합성합니다.]  
### [리플로우와 리페인트 최소화 방법]
리플로우와 리페인트를 유발하지 않는 CSS 속성을 활용하여 애니메이션이나 스타일 변경을 수행하는 것이 좋습니다. 예를 들어, transform이나 opacity를 사용하면 레이아웃이 변경되지 않으므로 리플로우와 리페인트가 발생하지 않고, 컴포지팅 단계에서만 처리됩니다.
반면 width나 margin과 같은 속성은 리플로우를 트리거할 가능성이 높기 때문에 초기 스타일 선언 시에만 설정하는 것이 효율적입니다.  

### 인터넷 창에서 www.google.com를 입력하면 무슨 일이 일어나는지 설명해주세요
먼저 사용자가 주소를 입력하면, 브라우저는 이 도메인 이름을 IP 주소로 변환해야 합니다. 이 과정을 DNS Lookup(조회)라고 합니다. 브라우저는 캐시된 DNS 기록을 먼저 확인하고, 없다면 로컬 DNS 서버에 요청하여 도메인에 해당하는 IP 주소를 얻습니다.
IP 주소가 확인되면, 브라우저는 서버와 TCP 연결을 수립합니다. TCP는 데이터를 신뢰성 있게 전달하기 위한 프로토콜입니다. 이 과정에서 브라우저는 서버와 3-way-handshake를 수행합니다. [즉, 브라우저가 SYN 패킷을 보내고, 서버가 SYN-ACK패킷을 보내며, 다시 브라우저가 ACK 패킷을 보내는 과정입니다.]
TCP 연결이 완료되면, 브라우저는 HTTP또는 HTTPS 요청을 보냅니다. 이 요청은 웹 페이지를 리소스를 요청하는 메세지입니다. HTTPS를 사용할 경우, 이 단계에서 SSL/TLS 핸드셰이크도 수행됩니다.  
서버는 요청을 받고, 해당 리소스를 브라우저에게 응답 보냅니다.  
마지막으로 받은 리소스들을 바탕으로 브라우저 렌더링 파이프라인을 진행합니다. DOM과 CSSOM을 생성하고, 렌더 트리를 구성한 뒤, 레이아웃과 페인트 단계를 통해 웹 페이지가 화면에 표시됩니다.  

### 리액트의 render phase와 commit phase에 대해서 설명해주세요
리액트의 렌더링 과정은 두 가지로 나눌 수 있습니다.

먼저 render phase는 리액트가 변화된 상태나 props에 따라 어떤 UI가 변경되어야 할지를 결정하는 단계입니다. 이 과정에서는 실제로 DOM을 업데이트하지 않고, 변경사항을 가상 DOM에서 계산하여 비교합니다. 이 단계는 순수하게 계산과정이기 때문에 성능에 영향을 주지 않도록 중단되거나 다시 실행될 수 있으며, React 18에서 도입된 Coneurrent Mode를 통해 비동기적으로 처리될 수도 있습니다.

다음으로 commit phase는 실제 변화된 UI를 DOM에 반영하는 단계입니다. 이때 리액트는 가상 DOM에서 계산된 결과를 실제 DOM에 적용하고, 변화된 UI를 브라우저에 렌더링합니다. 이 과정에서 useEffect와 같은 사이드 이펙트가 발생하는 훅들이 실행됩니다.

[정리하자면 render phase는 변화된 UI를 결정하는 과정이고, commit phase는 그 결정된 결과를 실제로 반영하는 단계입니다.]

![image](https://github.com/user-attachments/assets/b873017c-a28a-47e4-a51d-25c314a57f06)


### [그럼 render phase와 commit phase는 어떻게 동기화되나요?]

두가지의 단계로 말씀드릴 수 있습니다. 단계적 진행과 병목 관리입니다. 첫번째로 render phase가 완료되면 리액트는 즉시 commit하지 않고, 다른 높은 우선순위 작업이 있다면 먼저 처리한 후 나중에 commit phase를 실행할 수 있습니다. 이를 통해 React는 동기화가 필요한 작업을 효율적으로 관리합니다.

두번째로 병목 관리입니다. render phase에서 모든 변경 사항이 Fiber Tree에 준비된 상태에서 commit phase로 넘어가므로, render와 commit 단계의 일관성이 유지됩니다. 이렇게 두 단계는 순차적으로 작동하여, UI가 정확하게 동기화되고 불필요한 재렌더링을 방지합니다.


### 자바스크립트 호이스팅에 대해서 설명해주세요

호이스팅은 자바스크립트가 코드를 실행하기 전에 변수와 함수 선언을 코드의 최상단으로 끌어올리는 것처럼 동작하는 특징입니다. 이를 통해 코드 선언 위치와 관계 없이 변수를 사용할 수 있는 것처럼 보일 수 있습니다.  
하지만 호이스팅은 선언의 호이스팅일 뿐, 변수의 값 할당까지 끌어올려지지는 않습니다.  
예를 들어 var로 선언된 변수는 호이스팅 되지만, undefined로 평가됩니다.  
함수의 경우 함수 전체가 호이스팅되기 때문에 호출 이후에 선언해도 문제가 없습니다.  

그러나 ES6에 도입된 let과 const는 호이스팅이 되긴 하지만, 선언 전에 접근하면 ReferenceError가 발생합니다.  
이는 TDZ(Temporal Dead Zone)이라는 개념 때문인데요. TDZ는 변수가 선언되었지만 초기화되기 전가지의 구간을 말합니다. let과 const로 선언된 변수는 TDZ가 존재하며, 이 구간에서는 변수에 접근할 수 없습니다.


### 쿠키, 세션, 웹스토리지의 차이를 설명해보세요

먼저 쿠키는 서버와 클라이언트 데이터 교환에 사용됩니다. 키-값 쌍으로 저장되며 유효기간을 설정할 수 있습니다.  
세션은 서버에 데이터가 저장되며 클라이언트는 세션 ID만 저장합니다. 서버에서 관리되기 때문에 클라이언트에서는 데이터를 조작할 수 없습니다. 세션은 브라우저를 닫으면 만료됩니다.  
웹 스토리지는 브라우저 내부에서 데이터를 저장하며 브라우저를 닫아도 데이터가 삭제되지 않습니다. 쿠키와 동일하게 키-값 쌍으로 저장되며 데이터 교환 시 서버로 전송되지 않습니다.

### 자바스크립트 함수에 대해서 설명해주세요
자바스크립트 함수는 일급 객체로써 다뤄지며 클로저, 고차 함수, 화살표 함수 등의 기능들을 제공합니다.  
일급 객체의 특징은 자바스크립트 함수가 변수에 할당되거나, 다른 함수의 인자로 전달되거나, 함수에서 반환될 수 있다는 점입니다.  
또한 자바스크립트 함수는 함수의 이름이 없는 익명함수로 사용될 수 있으며, 변수에 값처럼 담는 함수 표현식으로도 사용할 수 있습니다.  
함수 선언은 코드가 실행되기 전에 호이스팅되어, 함수선언 이전에 호출할 수 있습니다.  
자바스크립트 함수는 클로저 기능도 제공합니다. 클로저는 함수가 자신이 선언된 환경, 즉 스코프를 기억하고 그 외부 스코프에 접근할 수 있는 기능입니다. 이를 통해 함수는 자신이 선언된 스코프 내의 변수를 참조하고 유지할 수 있습니다.  
마지막으로 고차함수 입니다. 자바스크립트에서는 함수가 일급 객체이기 때문에 다른 함수를 인자로 받거나 반환하는 고차함수를 정의할 수 있습니다.  

### CommonJS와 ES Module의 차이점에 대해서 설명해주세요
**CommonJS**와 **ES Module(ESM)** 은 자바스크립트에서 모듈을 관리하고 불러오는 방식입니다.  
**CommonJS**는 Node.js 환경에서 사용되며, 모듈을 동기적으로 불러옵니다. 주로 서버측에서 많이 사용됩니다.  
**ES Module(ESM)**은 자바스크립트 표준 모듈 시스템으로 ESM은 브라우저와 Node.js 환경에서 모두 사용할 수 있으며, 비동기적으로 로드합니다. 또한 ESM은 정적 분석이 가능해, 트리 쉐이킹과 같은 최적화 작업에도 유리합니다. ESM은 브라우저와 서버 모두에서 사용할 수 있습니다.

### 브라우저의 성능 최적화를 할 수 있는 방법에 대해서 설명해주세요
우선, 코드 스플리팅을 통해 자바스크립트 파일을 필요한 부분만 로드하여 로딩 속도를 개선할 수 있습니다.

또한 레이지 로딩 기법을 사용하여 이미지나 비디오 같은 무거운 리소스를 사용자가 실제로 볼 때만 로드하는 방식을 사용할 수 있습니다. 이렇게 하면 불필요한 리소스 로딩을 줄여 성능을 높일 수 있습니다.

이미지는 파일 크기를 줄이거나 WebP와 같은 가벼운 포맷으로 변환하는 방법이 있습니다.

또한, 캐싱을 활용해 한 번 로딩된 리소스를 다시 다운로드하지 않고 재사용할 수 있어 성능을 향상시킬 수 있습니다.

마지막으로, DOM 크기를 줄이거나 불필요한 CSS 및 자바스크립트 코드를 최소화하는 등의 리소스 최적화 방법을 적용하여 브리우저가 불필요한 렌더링을 하지 않도록 관리하는 것도 성능 개선에 도움이 됩니다.

### 디바운스와 쓰로틀에 대해서 설명해주세요
디바운스와 쓰로틀은 이벤트 핸들러가 너무 자주 실행되지 않도록 조절하는 기법입니다.

먼저 **디바운스**는 이벤트가 연속적으로 발생한 때, 마지막 **이벤트가 발생한 후 일정 시간이 지나야 이벤트 핸들러가 실행**되는 방식 입니다. 이를 통해 불필요하게 많은 이벤트 호출을 방지할 수 있습니다. 예를 들어, 검색창에 사용자가 키를 입력할 때마가 검색 요청을 보내면 부하가 지나치게 커지기 때문에, 사용자 입력을 멈춘 후 일정 시간이 지나면 검색 요청을 보내는 방식으로 적용할 수 있습니다.

**쓰로틀**은 일정 시간 간격 동안 발생한 이벤트 중 첫 번째 또는 마지막 이벤트만 처리하는 방식입니다. 즉, **이벤트가 계속해서 발생하더라도** 설정된 시간 동안은 **한 번만 이벤트 핸들러가 실행**됩니다. 예를 들어, 사용자가 연속 클릭을 한다면 클릭할 때마다 이벤트가 발생하는데, 이를 매번 처리하면 부하가 불필요하게 커지니 쓰로틀을 적용해 일정 간격 내 한 번만 처리하게 할 수 있습니다.

### 디바운스와 쓰로틀 중에서 무한 스크롤 구현 시 어떤 방식을 선택하시겠습니까? 그 이유는 무엇인가요?

무한 스크롤은 쓰로틀을 사용하는 것이 더 적합합니다.  
쓰로틀은 스크롤이 하단에 위치하게 된 순간 즉시 추가 데이터 요청을 수행하므로, 사용자에게 자연스러운 스크롤 경험을 제공할 수 있습니다.  
만약 디바운스를 사용할 경우 스크롤이 멈춘 후에야 데이터를 불러오기 시작하므로 지연이 발생할 수 있습니다.

### 리액트에서 index를 key값으로 사용하면 안되는 이유에 대해서 설명해주세요
리액트에서 index를 key로 사용하는 것을 권장하지 않는 이유는 배열의 요소들이 추가되거나 삭제될 때, 배열의 순서가 바뀌는 문제가 발생할 수 있기 때문입니다.

리액트는 key를 통해 리스트에서 어떤 요소가 변경, 추가, 삭제되었는지 추적합니다. 그러나 index를 key로 사용하면 배열의 순서가 변경될 때 리액트가 요소들을 잘못 인식해 불필요하게 재렌더링 하거나, 요소의 상태를 잘못 처리할 수 있습니다.

이로 인해 성능 문제가 발생하거나, 사용자 입력 상태 같은 요소가 의도치 않게 초기화되는 등 예기치 않은 버그가 생길 수 있습니다.

그래서 배열의 순서나 요소 변경에 영향을 받지 않는 고유한 key로 사용하는 것이 좋습니다.

### key로 사용되는 고유한 값의 생성 방법에는 어떤 것들이 있나요?

주로 데이터의 유일서을 보장하고 변하지 않는 값을 사용하는 것이 중요합니다. 이러한 경우 주로 서버의 데이터베이스에서 제공하는 고유 ID를 사용하는 것이 일반적입니다. 또한 UUID같이 전역적으로 고유한 id 생성이 가능한 라이브러리를 사용해볼 수도 있습니다.

### async/await에 대해 설명해보세요
async/await은자바스크립트에서 비동기 작업을 처리하는 문법입니다.  
`async` 키워드를 함수 앞에 붙이면 해당 함수는 항상 **Promise**를 반환합니다. 함수 내부에서 `await` 키워드를 사용하면, **Promise**가 처리될 때까지 기다린 후 결과 값을 반환할 수 있습니다.  
`async/await`는 기존의 **Promise** 체이닝 방식보다 코드 흐름을 더 직관적이고 간결하게 작성할 수 있게 해줍니다. 이를 통해 비동기 작업을 마치 동기 코드처럼 읽기 쉽게 표현할 수 있습니다.  

### useEffect와 useLayoutEffect의 차이점에 대해서 설명해주세요
useEffect는 렌더링이 완료되는 시점에 비동기적으로 실행됩니다. 즉, 화면이 실제로 사용자에게 그려진 후 useEffect가 실행되는 방식입니다. 그래서 보통 데이터를 가져오는 작업이나 이벤트 리스너 추가 등 렌더링 후에 화면에 직접적인 영향을 주지 않는 작업에 주로 사용됩니다.  
useLayoutEffect는 렌더링 후 DOM이 없데이트되기 직전의 시점에 동기적으로 실행됩니다. 여기서 동기적이라는 것은 화면에 내용이 그려지기 전에 모든 레이아웃 관련 작업이 완료된다는 의미입니다.예를 들어 DOm 의 크기를 측정하거나 위치를 조정해야 할 때 useLayoutEffect를 사용하면 즉각적으로 그 변경사항이 반영되어 화면 깜빡임이나 불필요한 재렌더링을 방지할 수 있습니다.  
단, useLayoutEffect사용 시 성능 면에서 주의할 점이 있습니다. useLayoutEffect는 동기적으로 실행되기 때문에 너무 많은 작업이 실행되면 렌더링이 느려질 수 있습니다. 따라서 보통 useEffect를 기본적으로 사용하고, 화면에 영향을 주는 작업만 useLayoutEffect로 처리하는 것이 좋습니다.  

### 웹 접근성의 개념과 개선 방법에 대해 설명해주세요
웹 접근성은 장애인과 고령자 등 신체적 제약이 있는 사용자를 포함해, 모든 사용자가 웹 페이지를 동등하게 이용할 수 있도록 보장하는 개념입니다.  
웹 접근성 개선에는 다양한 방법이 있습니다. 우선, 단순하고 명확한 HTML 구조와 시맨틱 태그가 필요합니다. 또한 ARIA속성을 활용하여 스크린 리더가 동적 콘텐츠나 복잡한 UI 요소를 올바르게 인식할 수 있게 만들 수 있습니다.  
마지막으로, 키보드로도 페이지를 탐색할 수 있도록 포커스를 명확히 지정하여 키보드 사용자가 필요한 정보에 접근하기 쉽게 해야 합니다.  

### 말씀해주신 방법으로 개선하면 웹 접근성은 완벽해지는 건가요?
웹 접근성을 완벽히 구현하려면 시각 장애뿐만 아니라 청각 장애, 운동 장애, 인지 장애에 대해서도 고려해야 합니다.  
하지만, 모든 장애 유형을 완벽히 대응하는 것은 현실적으로 어렵습니다. 따라서, 단순히 많은 항목을 충족하는 데 매몰되기 보다는, 우리 서비스에서 각 장애 유형 별로 사용자가 어떤 경험을 하고 있는지 파악하는 것이 중요합니다. 예를 들면, 스크린 리더로 탐색해보면 시각 장애 사용자가 어떤 경험을 하고 있는지 파악할 수 있습니다. 이러한 정보를 기반으로 우선순위를 정렬하고, 기업의 상황에 맞게 점진적으로 접근성을 개선해 나가는 것이 지속 가능하고 현실적인 방식일 것입니다.  

### SSR(Server Side Rendering)에 대해 설명해주세요
서버사이드 렌더링 방식은 초기 화면을 클라이언트가 아닌 서버에서 렌더링하여 완성된 HTML을 클라이언트에 내려주는 방식입니다. SSR에서는 서버 단에서 HMTL을 완성해 클라이언트에 전송하고, 클라이언트가 해당 HTML을 파싱만 하여 화면을 그리는 방식입니다.  
반면, 클라이언트사이드 렌더링 방식에서는 브라우저가 서버로부터 비어있는 HTML을 받아온 후, 필요한 자바스크립트 번들을 다운로드하고 실행하여 동적으로 컨텐츠를 채웁니다.  

### SSR의 장점은 무엇인가요?
검색엔진 최적화 측면에서 유리합니다. 화면이 동적으로 그려지는 CSR에 비해 검색 엔진이 크롤링할 때 쉽게 컨텐츠를 인식할 수 있기 때문입니다. 이런 점에서 SSR은 블로그나 커머스 등 SEO가 중요한 웹 애플리케이션에 적합합니다.  
또한, SSR 방식에서는 사용자가 빠른 초기 로딩 속도를 경험할 수 있습니다. CSR과 달리 SSR에서는 번들을 다운로드 받을 필요가 없고, 번들을 실행하여 동적으로 화면을 그려야 할 필요도 없기 때문입니다.  

### SSR의 단점은 없나요?
첫째, 상호작용 초기화가 느립니다. 이는 페이지가 표시되기까지 걸리는 시간(TTV)과 상호작용까지 걸리는 시간(TTI) 사이에 격차가 발생한다는 의미입니다. 그 사이에 사용자가 버튼을 클릭해도 동작하지 않는 등의 답답한 상황을 겪을 수 있습니다.  
둘째, 상대적으로 구현 난이도가 높습니다. 자바스크립트 번들로 대부분의 작업이 수행되는 CSR에 비해 SSR은 과정이 복잡하기 때문입니다.  
마지막으로, 서버 비용이 증가합니다. 정적인 파일을 내려주기만 하면 되는 CSR과 달리, 동적으로 HMTL을 생성하기 위해 서버를 구동해야 하기 때문입니다.  

### CSS Flexbox와 Grid의 차이점에 대해서 설명해주세요
Flexbox는 **1차원 레이아웃이지만, Grid는 2차원 레이아웃**입니다.  
Flexbox는 1차원 레이아웃 속성으로, row 또는 column중 하나를 기준으로 요소를 정렬하고 배치하는 데 최적화되어 있습니다. 주로 행이나 열 중 하나의 방향으로 정렬해야 할 때 유용하며, 복잡한 행과 열을 모두 포함하는 레이아웃에서는 다소 한계가 있습니다.  
Grid는 2차원 레이아웃 속성으로, 행과 열 모두 사용해 요소를 배치할 수 있습니다. 따라서 복잡한 레이아웃을 구성하거나, 웹페이지의 전체적인 구조를 잡는 데 적합합니다.  
또한 사용 목적의 차이가 있습니다.  
Flexbox는 콘텐츠 중심으로, 콘텐츠가 추가되거나 중러들 때 유연하게 대처하기 좋습니다. 예를 들어, 수평 또는 수직 방향으로 콘텐츠를 정렬하고 간격을 조절하는 데 유용하며, 버튼 그룹, 내비게이션 바 등 한 줄의 콘텐츠가 주가 되는 구성에 적합합니다.  
Grid는 레이아웃 중심으로 페이지 구조를 구성하는 데 최적화되어 있습니다. 예를 들어, 카드 레이아웃, 갤러리 형식 등 명확하게 구분된 영역을 기반으로 레아아웃을 구성할 때 효과적입니다.  
마지막으로 기본 동작의 차이가 있습니다.  
Flexbox에서는 주로 요소가 컨테이너의 크기나 위치에 맞춰 자동으로 정렬됩니다.  justify-content와 align-items 속성을 사용해, 주 축 방향으로 요소들을 배치하고 여백을 조절할 수 있습니다.  
Grid는 행과 열을 사전에 정의하고 그 격자(grid cell)에 요소를 배치하는 방식입니다. grid-template-rows, grid-template-columns와 같은 속성으로 행과 열의 크기를 정의하고, 각 요소의 위치를 세밀하게 설정할 수 있습니다.  

### 프론트엔드 E2E 테스트에 대해서 설명해주세요
프론트엔드 E2E테스트는 애플리케이션의 사용자 경험을 처음부터 끝까지 시뮬레이션하여 테스트하는 방식입니다. 단위 테스트나 통합 테스트와 달리, E2E테스트는 사용자 관점에서 전체 애플리케이션이 의도한 대로 작동하는지 검증합니다. 브라우저 환경에서 실제 사용자 동작을 흉내 내어 다양한 시나리오를 테스트하며, 버튼 클릭, 페이지 이동, 데이터 입력 등을 포함합니다. 보통 E2E 테스트는 Cypress, Playwright과 같은 도구를 이용해 작성합니다.  
E2E테스트를 진행하면서 사용자와 동일한 방식으로 애플리케이션을 테스트하므로, 사용자에게 직접적인 영향을 미치는 오류를 조기에 발견할 수 있습니다.  
이는 프로덕트의 안정성을 높이고, 실제 배포 후 발생할 수 있는 리스크를 줄이는 데 도움이 됩니다. 따라서 E2E 테스트는 중요한 사용자 흐름이나 비즈니스 로직이 포함된 페이지에 적용하면 효과적입니다.  

### 유닛 테스트로도 충분히 안정성을 높이고, 리스크를 줄일 수 있지 않나요?
유닛 테스트는 개별적인 코드 조각이 제대로 작동하는지 확인하지만, 전체 시스템의 흐름과 사용자가 실제로 겪는 경험을 확인하지는 않습니다. 예를 들어, 로그인 기능의 유닛 테스트는 올바른 사용자 정보를 입력했을 때 인증이 성공하는지를 확인할 수 있지만, 로그인 이후의 페이지 이동, 세션 유지, 렌더링 등은 확인하지 못합니다.  
반면, E2E 테스트는 애플리케이션을 사용자 관점에서 처음부터 끝까지 검사하여, 모든 시스템이 잘 작동하는지 확인합니다.  
따라서 유닛 테스트와 E2E 테스트를 상호 보완적으로 함께 활용하는 것이 좋습니다. 두 테스트를 함께 활용하면 애플리케이션의 안정성과 신뢰성을 극대화할 수 있습니다.  

### 이미지 크기가 클 경우 렌더링 속도가 느려질 텐데, 이를 개선하기 위한 방법들을 설명해주세요
먼저 이미지 포맷 최적화방법이 있습니다. jpeg나 png 대신, 압축 효율이 높은 webP 또는 AVIF와 같은 최신 포맷으로 변환할 수 있습니다. 이 포맷은 이미지 품질을 유지하면서 파일 크기를 크게 줄여줍니다.  
다음 이미지 사이즈 조정입니다. 화면에 노출되는 크기에 비해 이미지가 과도하게 큰 경우 이미지를 작게 리사이징할 수 있습니다. 또한, 다양한 디바이스 해상도에 대응하기 위해 Responsive Images 기술, 즉 `srcset`과 `sizes` 속성을 활용할 수 있습니다. 이 경우, 브라우저가 현재 화면 크기에 최적화된 이미지를 선택하여 로드할 수 있습니다.  
지연 로딩 방법도 있습니다. 사용자가 화면에 스크롤할 때 해당 위치에 도달하는 이미지가 로드되도록 설정하는 방법입니다. 지연 로딩을 통해 초기 로딩 속도를 개선할 수 있습니다. HTML loading=”lazy”속성을 통해 구현할 수 있으며, 불필요한 이미지 로드를 방지할 수 있습니다.  
마지막으로 CDN입니다. CDN을 적용하면 사용자가 지리적으로 가까운 서버에서 이미지를 다운로드하게 되어 로딩 속도를 단축시킬 수 있습니다.  

### WebP나 AVIF는 모든 브라우저에서 지원하지 않는다고 하셨는데, 호환성 문제를 어떻게 해결할 수 있을까요?
호환성 문제에 대비하기 위해 HTML의 `<picture>` 요소를 통해 fallback 이미지를 적용할 수 있습니다. `<picture>` 요소 내부에 WebP나 AVIF와 같은 고효율 포맷을 우선 설정하고, 브라우저가 이를 지원하지 않을 경우 JPEG나 PNG와 같은 기본 포맷을 로드하도록 할 수 있습니다.  
구체적인 예시는 아래와 같습니다.

```html
<picture>
	<source srcset="image.avif" type="image/avif">
	<source srcset="image.webp" type="image/webp">
	<img src="image.jpg" alt="Image description">
</picture>
```

이 코드에서 브라우저는 AVIF를 우선 시도하고, 지원하지 않으면 WebP를, 둘 다 지원하지 않으면 마지막 img 태그의 jpg 이미지를 로드하게 됩니다.  

### 자바스크립트는 싱글 스레드 언어인데, 어떻게 동시에 여러 작업들을 수행하나요?
자바스크립트는 싱글 스레드 언어로 한 번에 하나의 작업만을 처리할 수 있는 단일 콜 스택을 가집니다. 하지만 브라우저나 Node.js환경이 제공하는 비동기 처리 메커니즘 덕분에 여러 작업을 동시에 수행할 수 있습니다.  
자바스크립트는 브라우저의 Wep API나 이벤트 루프, 태스크 큐를 이용해 비동기 작업을 동시에 처리합니다.  
비동기 작업이 발생하면, 해당 작업은 브라우저의 Web API에 위임됩니다. 예를 들어, setTimeout이나 fetch와 같은 작업이 수행되면 자바스크립트 엔진은 이 작업들을 Web API에 넘기고 다른 코드실행을 이어갑니다. Web API에서 비동기 작업이 완료되면, 그 작업은 태스크 큐에 들어가 대기합니다.  
이후 **이벤트 루프**가 콜 스택이 비어있는지 확인한 뒤 태스크 큐에서 대기 중인 작업을 콜 스택으로 가져와 실행합니다. 이러한 구조 덕분에 자바스크립트는 싱글 스레드임에도 비동기적으로 작업을 처리하여 다양한 작업을 효율적으로 관리할 수 있습니다. 이 메커니즘 덕분에 UI 인터랙션이 끊기지 않으며, 대기 시간이 필요한 작업도 동시에 실행되는 것과 같이 동작하게 됩니다.

### 앞서 말씀하신 태스크 큐의 종류에는 어떤 게 있나요?
자바스크립트의 태스크 큐는 크게 **매크로태스크 큐**와 **마이크로태스크 큐**로 나뉩니다. 이들 큐는 비동기 작업의 우선순위를 관리하고, 이벤트 루프가 적절한 시점에 콜백을 실행하기 위해 사용됩니다.  
**매크로태스크 큐**는 일반적인 비동기 작업의 콜백이 저장되는 큐입니다.  
setTimeout, setInterval, I/O작업, 이벤트 핸들러 등은 작업 완료 후 매크로태스크 큐에 콜백을 대기시킵니다. 매크로태스크 큐는 이벤트 루프의 한 번의 반복마다 하나의 태스크만 처리되므로, UI 업데이트나 다른 작업과 균형있게 진행됩니다.  
**마이크로태스크 큐**는 더 높은 우선순위가 필요한 비동기 작업들이 대기하는 큐입니다.  
`Promise.then`, `MutationObserver` 등의 비동기 콜백이 여기에 저장됩니다. 이벤트 루프는 매크로태스크를 실행하기 전에 항상 마이크로태스크 큐를 먼저 확인하고, 모든 마이크로태스크를 처리한 후 매크로태스크로 넘어갑니다. 이 방식으로 마이크로태스크 큐의 작업은 높은 우선순위로 처리됩니다.  
