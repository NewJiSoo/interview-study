### 리액트에서 성능 최적화를 위한 방법들을 설명해주세요.

리액트에서 성능 최적화를 위한 여러 가지 방법이 있습니다.
주로 메모이제이션을 활용하는 방법과 코드 분할 방법으로 나눌 수 있는데요,
React.memo, useMemo, useCallback 같은 메모이제이션 기법들과 React.lazy와 Suspense를 활용한 코드 스플리팅이 대표적입니다.
불필요한 리렌더링을 방지하고 초기 로딩 속도를 개선하는 데 도움이 됩니다.

##### 예상 꼬리 질문

### React.memo, useMemo, useCallback의 차이점을 설명해주세요.

각각의 메모이제이션 기법은 서로 다른 용도로 사용됩니다.

1. 먼저 React.memo는 컴포넌트 자체를 메모이제이션합니다. props가 변경되지 않으면 리렌더링을 방지하여, 특히 부모 컴포넌트가 자주 리렌더링되는 상황에서 성능 최적화에 유용합니다.
2. useMemo는 값을 메모이제이션하는데, 특히 계산 비용이 큰 연산 결과를 재사용할 때 사용합니다. 의존성 배열의 값이 변경될 때만 재계산이 이루어지므로 불필요한 연산을 줄일 수 있습니다.
3. useCallback은 함수를 메모이제이션합니다. 주로 자식 컴포넌트에 props로 전달되는 콜백 함수를 최적화할 때 사용하며, 함수가 불필요하게 재생성되는 것을 방지합니다.

다만 주의할 점은, 이러한 최적화 기법들은 실제로 성능 개선이 필요한 경우에만 사용해야 한다는 것입니다. 불필요한 메모이제이션은 오히려 성능을 저하시킬 수 있기 때문입니다.

---

### 브라우저 렌더링 파이프라인에 대해서 설명해주세요.

브라우저가 웹페이지를 렌더링하는 과정은 여러 단계로 이루어집니다.

1. HTML을 파싱하여 DOM 트리를 생성합니다. 이는 문서의 구조를 나타내는 기본적인 단계입니다.
2. CSS를 파싱하여 CSSOM 트리를 생성합니다. 이는 스타일 정보를 구조화하는 과정입니다.
3. DOM 트리와 CSSOM 트리를 결합하여 렌더 트리를 생성합니다. 이 렌더 트리에는 실제로 화면에 표시될 요소들만 포함됩니다.
4. 레이아웃 단계에서는 각 요소들의 크기와 위치를 계산합니다. 뷰포트 내에서 각 요소가 정확히 어디에 위치해야 하는지 결정됩니다.
5. 페인팅 단계에서는 실제 픽셀로 그리는 작업이 이루어집니다. 각 요소의 색상, 그림자 등 시각적인 부분이 처리됩니다.
6. 컴포지팅 단계에서는 여러 레이어를 결합하여 최종 화면을 구성합니다. 이렇게 여러 단계를 거쳐 사용자는 완성된 웹페이지를 보게 됩니다.

---

### 인터넷 창에서 URL을 입력하면 무슨 일이 일어나는지 설명해주세요.

브라우저에서 URL을 입력하면 여러 단계의 과정이 순차적으로 진행됩니다.

1. DNS 조회입니다. 브라우저는 먼저 자신의 DNS 캐시를 확인하고, 찾고자 하는 도메인이 없다면 DNS 서버에 요청하여 해당 URL의 실제 IP 주소를 찾아냅니다.
2. 찾은 IP 주소로 TCP 연결을 수립합니다. TCP 연결이 완료되면 브라우저는 HTTP 나 HTTPS 요청을 보내게 되는데, HTTPS의 경우 서버와의 보안 연결을 위해 TLS 핸드셰이크 과정을 추가로 거칩니다.
3. 서버는 이 요청을 받아 처리한 후 필요한 리소스들을 응답으로 전송하고, 마지막으로 브라우저는 받은 리소스들을 바탕으로 렌더링을 시작합니다.

---

### 리액트의 render phase와 commit phase에 대해서 설명해주세요.

리액트의 렌더링은 크게 render phase와 commit phase로 나눌 수 있습니다.

1. render phase는 컴포넌트의 변경사항을 파악하는 단계입니다. 상태나 props가 변경되었을 때 리액트는 가상 DOM에서 이 변경사항들을 계산하고 비교하며, 실제 DOM에 어떤 변경이 필요한지 결정합니다. 이 단계에서는 아직 실제 DOM에 변경을 가하지 않습니다.
2. commit phase는 앞서 결정된 변경사항을 실제 DOM에 반영하는 단계입니다. 이때 리액트는 가상 DOM의 계산 결과를 실제 DOM에 적용하고, useEffect와 같은 부수 효과들이 실행됩니다.

##### 예상 꼬리 질문

### 그럼 render phase와 commit phase는 어떻게 동기화되나요?

이 두 단계는 매우 체계적으로 동기화됩니다.

1. render phase가 완료되더라도 리액트는 즉시 commit phase를 실행하지 않을 수 있습니다. 더 높은 우선순위의 작업이 있다면 그것을 먼저 처리하고 나중에 commit phase를 실행하는 방식으로 작업을 효율적으로 관리합니다.
2. Fiber Tree를 통해 변경사항의 일관성을 유지합니다. render phase에서 모든 변경사항이 Fiber Tree에 준비된 상태로 commit phase로 넘어가기 때문에, 두 단계 사이의 동기화가 정확하게 이루어지고 불필요한 렌더링도 방지할 수 있습니다.

---

### 자바스크립트 호이스팅에 대해서 설명해주세요.

자바스크립트의 호이스팅은 코드 실행 전에 변수와 함수의 선언부가 스코프의 최상단으로 끌어올려지는 것처럼 동작하는 특징입니다.
이는 실제로 코드가 이동하는 것이 아니라, 자바스크립트 엔진이 코드를 실행하기 전에 선언문들을 먼저 처리하는 방식입니다.
중요한 점은 호이스팅은 선언부만 끌어올려지고 할당은 끌어올려지지 않는다는 것입니다.
var로 선언한 변수는 호이스팅 시 undefined로 초기화되지만, let과 const로 선언한 변수는 TDZ(Temporal Dead Zone)에 의해 초기화 전 접근 시 참조 에러가 발생합니다.

---

### 쿠키, 세션, 웹스토리지의 차이를 설명해보세요.

웹에서 데이터를 저장하는 방식은 크게 쿠키, 세션, 웹스토리지로 나눌 수 있습니다.

1. 쿠키는 클라이언트와 서버 간의 지속적인 데이터 교환을 위해 사용됩니다. HTTP의 무상태성을 보완하기 위해 만들어졌으며, 브라우저에 저장되어 매 HTTP 요청 시 서버로 자동 전송되는 특징이 있습니다.
2. 세션은 서버 측에서 사용자의 상태 정보를 저장하고 관리하는 방법입니다. 서버는 클라이언트에게 고유한 세션 ID를 발급하고, 이 ID를 통해 서버에 저장된 사용자 정보를 식별합니다. 세션 ID는 주로 쿠키를 통해 클라이언트에 저장되며, 보안이 중요한 사용자 인증 정보 같은 데이터를 다룰 때 주로 사용됩니다. 세션은 서버 메모리에 저장되기 때문에 서버 자원을 사용하며, 사용자가 브라우저를 종료하거나 서버에서 세션을 삭제했을 때 종료됩니다.
3. 웹스토리지는 HTML5에서 도입된 저장소로, 로컬스토리지와 세션스토리지로 나뉩니다. 로컬스토리지는 브라우저를 닫아도 데이터가 유지되고, 세션스토리지는 탭이나 창을 닫으면 데이터가 삭제됩니다. 두 저장소 모두 서버로 자동 전송되지 않아 클라이언트 측 데이터 저장에 효과적이지만, 보안상 중요한 정보는 저장하지 않는 것이 좋습니다.

---

### 자바스크립트 함수에 대해서 설명해주세요.

자바스크립트에서 함수는 일급 객체로 취급되며, 이는 함수를 변수에 할당하거나, 다른 함수의 매개변수로 전달하거나, 함수에서 반환할 수 있다는 것을 의미합니다.
함수는 여러 가지 특징을 가지고 있습니다. 익명 함수를 통해 이름 없이 함수를 정의할 수 있으며, 함수 선언문은 호이스팅되어 선언 이전에도 호출이 가능합니다. 반면 함수 표현식은 변수에 할당된 후에만 사용할 수 있습니다.
또한 클로저를 통해 함수가 자신이 선언된 스코프의 변수에 접근할 수 있으며, 화살표 함수를 통해 더 간결한 문법으로 함수를 작성할 수 있습니다. 이러한 특징들은 자바스크립트에서 함수를 매우 유연하게 사용할 수 있게 해줍니다.

##### 예상 꼬리 질문

### 클로저에 대해 설명해주세요.

클로저는 함수가 선언될 당시의 주변 환경을 기억하고 있다가, 나중에 그 함수가 호출될 때도 이 환경에 접근할 수 있게 해주는 개념입니다.
쉽게 말해서, 함수가 자신이 생성될 당시의 스코프를 기억하고 있다가 나중에 자신이 선언된 곳이 아닌 다른 곳에서 호출되어도 그 스코프에 접근할 수 있게 해주는 것입니다.
클로저는 실제로 많이 활용되는데요, 예를 들어 데이터를 비공개로 유지하면서도 이 데이터에 접근하고 조작할 수 있는 메서드를 제공하고 싶을 때 사용합니다.
카운터 기능을 만든다고 생각해보면, 카운트 값은 외부에서 직접 접근할 수 없게 하고, 오직 증가나 감소 같은 메서드를 통해서만 조작할 수 있게 만들 수 있습니다.
다만 클로저를 사용할 때는 메모리 관리에 주의해야 합니다. 클로저가 생성되면 함수가 참조하는 환경이 계속 메모리에 유지되기 때문에, 더 이상 필요하지 않은 클로저는 적절히 해제해주는 것이 좋습니다.
이런 메모리 관리가 제대로 이루어지지 않으면 메모리 누수가 발생할 수 있기 때문입니다.

---

### CommonJS와 ES Module의 차이점에 대해서 설명해주세요.

자바스크립트에서 모듈을 다루는 방식은 크게 CommonJS와 ES Module이 있습니다.

1. CommonJS는 Node.js 환경에서 주로 사용되는 방식으로, 모듈을 동기적으로 불러옵니다. require 키워드로 모듈을 가져오고 module.exports로 내보내는데, 모듈이 완전히 로드될 때까지 다음 코드가 실행되지 않는 특징이 있습니다.
2. 반면 ES Module은 ES6부터 도입된 자바스크립트의 공식 모듈 시스템입니다. import와 export 키워드를 사용하며, 비동기적으로 모듈을 불러올 수 있습니다. 브라우저와 Node.js 환경 모두에서 사용 가능하며, 최근에는 풀스택 애플리케이션의 호환성을 위해 ES Module 사용이 증가하는 추세입니다.

---

### 이벤트 전파(Event Propagation)에 대해서 설명해주세요.

웹 브라우저에서 이벤트가 발생했을 때, 이 이벤트는 DOM 트리를 따라 특정한 순서로 전파됩니다. 이 과정은 세 단계로 이루어지는데요.

1. 캡처링 단계입니다. 이벤트가 최상위 요소에서 시작해서 이벤트가 발생한 요소까지 내려가는 과정입니다. 이때 경로상의 요소에 캡처링 이벤트 리스너가 있다면 순서대로 실행됩니다.
2. 타겟 단계로, 실제 이벤트가 발생한 요소에 도달하여 해당 요소의 이벤트 리스너가 실행되는 단계입니다.
3. 버블링 단계입니다. 이벤트가 다시 타겟 요소부터 최상위 요소까지 거슬러 올라가면서, 경로상의 요소들에 등록된 이벤트 리스너들이 실행됩니다.

##### 예상 꼬리 질문

### 이벤트 전파를 막는 방법에 대해서 설명해주세요.

이벤트 전파를 막는 방법은 크게 두 가지가 있습니다.

1. event.stopPropagation()을 사용하는 방법입니다. 이는 이벤트의 추가적인 전파를 중단시켜서, 상위 요소들로 이벤트가 전달되는 것을 막습니다.
2. event.preventDefault()를 사용하는 방법인데요, 이는 이벤트의 기본 동작 자체를 취소합니다. 폼 제출이나 링크 클릭 같은 브라우저의 기본 동작을 막고 싶을 때 사용합니다.

이 두 메서드는 목적이 다른데, stopPropagation은 이벤트 전파를 막는 것이고, preventDefault는 기본 동작을 막는 것입니다. 상황에 따라 적절한 메서드를 선택해서 사용하면 됩니다.

---

### 웹 애플리케이션의 성능을 최적화할 수 있는 방법들에 대해서 설명해주세요.

웹 애플리케이션의 성능을 개선하는 방법은 여러 가지가 있습니다.
가장 기본적인 방법은 코드 스플리팅입니다. 애플리케이션을 더 작은 번들로 나누어서, 사용자가 현재 필요한 코드만 먼저 다운로드받게 하는 방식입니다.
또한 레이지 로딩 기법을 사용하면 이미지나 비디오 같은 무거운 리소스들을 실제로 화면에 표시될 때만 로드하도록 할 수 있습니다. 이는 초기 로딩 시간을 크게 단축시킬 수 있습니다.
이미지 최적화도 중요한 방법인데요, WebP같은 최신 포맷을 사용하거나 이미지 크기를 적절히 조절하여 파일 크기를 줄일 수 있습니다.
마지막으로 캐싱 전략을 잘 활용하면 한번 받아온 리소스를 브라우저에 저장해두고 재사용할 수 있어, 불필요한 네트워크 요청을 줄일 수 있습니다.

---

### 디바운스와 쓰로틀에 대해서 각각 설명해주세요.

디바운스와 쓰로틀은 이벤트 핸들러가 많이 호출될 때 제어하는 방법입니다.

1. 디바운스는 연속된 이벤트 중 마지막 이벤트가 발생하고 일정 시간이 지난 후에 한 번만 핸들러를 실행하는 방식입니다. 예를 들어 검색 입력 시 타이핑이 끝나고 500ms 후에 검색 요청을 보내는 식으로 사용됩니다.
2. 쓰로틀은 이벤트가 발생하더라도 일정 시간 동안은 한 번만 핸들러를 실행하는 방식입니다. 예를 들어 스크롤 이벤트에서 200ms마다 한 번씩만 핸들러를 실행하도록 제한하는 식입니다.

### 디바운스와 쓰로틀 중에서 무한 스크롤 구현 시 어떤 방식을 선택하시겠습니까?

무한 스크롤에는 쓰로틀이 더 적합합니다.
디바운스는 스크롤이 완전히 멈춰야만 데이터를 불러오기 때문에 사용자 경험이 자연스럽지 않을 수 있습니다.
반면 쓰로틀은 스크롤 중에도 일정 간격으로 데이터를 불러올 수 있어 더 부드러운 경험을 제공할 수 있습니다.

---

### 리액트에서 index를 key값으로 사용하면 안되는 이유에 대해서 설명해주세요.

리액트에서 index를 key로 사용하면 몇 가지 문제가 발생할 수 있습니다.
리액트는 key를 통해 어떤 요소가 변경, 추가, 삭제되었는지 판단하는데, index를 key로 사용하면 배열의 순서가 바뀌었을 때 문제가 생깁니다.
예를 들어 배열 앞쪽에 새로운 항목이 추가되면, 그 뒤의 모든 항목들의 index가 바뀌게 됩니다.
이때 리액트는 실제로는 같은 항목인데도 다른 항목으로 인식하게 되어, 불필요한 리렌더링이 발생하거나 상태가 꼬일 수 있습니다.

### key로 사용되는 고유한 값은 어떻게 만들 수 있나요?

보통은 데이터베이스의 고유 ID를 사용하거나, uuid 같은 라이브러리를 사용해서 고유한 값을 생성합니다.
데이터의 고유한 속성이 있다면 그것을 key로 사용할 수도 있습니다. 중요한 것은 해당 목록 내에서 변하지 않는 유일한 값이어야 한다는 점입니다.

---

### async/await에 대해 설명해보세요.

async/await는 비동기 처리를 위한 직관적인 문법입니다. Promise를 기반으로 하지만, 더 쉽고 읽기 좋은 코드를 작성할 수 있게 해줍니다.
async 키워드를 함수 앞에 붙이면 해당 함수는 항상 Promise를 반환하게 되고, 그 함수 내부에서 await 키워드를 사용할 수 있습니다. await는 Promise의 실행이 완료될 때까지 기다렸다가 그 결과값을 반환해주므로, 비동기 작업을 마치 동기 작업처럼 작성할 수 있습니다.

---

### useEffect와 useLayoutEffect의 차이점에 대해서 설명해주세요.

useEffect와 useLayoutEffect는 모두 부수 효과를 처리하기 위한 Hook이지만, 실행 시점에 차이가 있습니다.
useEffect는 화면 렌더링이 완료된 후 비동기적으로 실행됩니다. 대부분의 경우 useEffect를 사용하는 것이 좋은데, 데이터 페칭이나 이벤트 리스너 등록 같은 작업에 적합합니다.
반면 useLayoutEffect는 DOM 업데이트 직후, 화면이 그려지기 전에 동기적으로 실행됩니다. 주로 DOM을 직접 조작하거나 레이아웃 측정이 필요한 경우에 사용합니다. 화면 깜빡임을 방지해야 할 때 유용하지만, 성능에 영향을 줄 수 있어 필요한 경우에만 사용해야 합니다.

---

### SSR(Server Side Rendering)에 대해 설명해주세요.

SSR은 서버에서 페이지의 HTML을 미리 생성해서 클라이언트에 전송하는 렌더링 방식입니다.
서버에서 완성된 HTML을 받은 브라우저는 즉시 화면을 그릴 수 있고, 이후 hydration 과정을 통해 자바스크립트를 실행하여 페이지를 상호작용 가능한 상태로 만듭니다.
반면 CSR은 빈 HTML을 받은 후 클라이언트에서 자바스크립트로 콘텐츠를 렌더링합니다.

### SSR의 장점은 무엇인가요?

SSR의 가장 큰 장점은 검색엔진 최적화(SEO)에 유리하다는 점입니다. 검색엔진이 페이지의 콘텐츠를 쉽게 크롤링할 수 있기 때문입니다.
또한 초기 페이지 로딩이 빠르고 사용자가 의미 있는 콘텐츠를 더 빨리 볼 수 있어 사용자 경험도 개선됩니다.

### SSR의 단점은 없나요?

SSR에도 몇 가지 중요한 단점이 있습니다.

1. 먼저 TTV(Time to View)와 TTI(Time to Interact) 사이의 간격이 발생합니다. 즉, 콘텐츠는 빨리 보이지만 실제로 상호작용이 가능해지기까지 시간이 걸립니다.
2. 서버에서 렌더링을 처리해야 하므로 서버 부하가 증가하고, 그에 따른 비용도 증가합니다.
3. 마지막으로 CSR에 비해 구현이 복잡하고 개발 난이도가 높습니다.

---

### CSS Flexbox와 Grid의 차이점에 대해서 설명해주세요.

Flexbox와 Grid는 모두 현대적인 레이아웃 시스템이지만 사용 목적이 다릅니다.

1. Flexbox는 1차원적 레이아웃을 위한 시스템입니다. 주로 행이나 열 중 한 방향으로 요소들을 배치하고 정렬하는 데 강점이 있으며, 요소들의 크기가 유동적일 때 특히 유용합니다.
2. Grid는 2차원적 레이아웃을 위한 시스템입니다. 행과 열을 모두 고려하여 더 복잡한 레이아웃을 구성할 수 있으며, 전체적인 페이지 구조를 잡는 데 적합합니다. 미리 정의된 격자에 요소들을 배치하는 방식이라 더 정교한 레이아웃 구성이 가능합니다.

---

### 프론트엔드 E2E 테스트에 대해서 설명해주세요.

E2E(End-to-End) 테스트는 실제 사용자의 행동을 시뮬레이션하여 애플리케이션의 전체적인 흐름을 테스트하는 방법입니다.
Cypress나 Playwright 같은 도구를 사용해 실제 브라우저 환경에서 테스트를 수행하며, 사용자 시나리오를 기반으로 애플리케이션이 정상적으로 동작하는지 확인합니다.

### 유닛 테스트로도 충분하지 않나요?

유닛 테스트와 E2E 테스트는 각각의 역할이 다릅니다.
유닛 테스트는 개별 컴포넌트나 함수가 정상적으로 동작하는지 확인하는 데 중점을 두지만, 실제 사용자 경험이나 컴포넌트 간의 상호작용은 확인하기 어렵습니다.
따라서 두 가지 테스트를 상호 보완적으로 사용하는 것이 좋습니다.
유닛 테스트로 개별 기능의 정확성을 보장하고, E2E 테스트로 전체 시스템의 통합적인 동작을 검증하면 애플리케이션의 안정성을 더욱 높일 수 있습니다.

---

### 이미지 크기가 클 경우 렌더링 속도를 개선하기 위한 방법들을 설명해주세요.

이미지 렌더링 속도를 개선하기 위한 여러 가지 효과적인 방법들이 있습니다.

1. 이미지 포맷을 최적화할 수 있습니다. WebP나 AVIF 같은 최신 포맷을 사용하면 화질은 유지하면서도 파일 크기를 크게 줄일 수 있습니다. 다만 브라우저 호환성을 고려해야 합니다.
2. 반응형 이미지 기술을 활용할 수 있습니다. 디바이스 크기에 맞는 최적화된 이미지를 제공함으로써 불필요하게 큰 이미지를 다운로드하는 것을 방지할 수 있습니다.
3. 지연 로딩(Lazy Loading)을 구현할 수 있습니다. 페이지 초기 로딩 시 모든 이미지를 한꺼번에 로드하지 않고, 사용자의 뷰포트에 들어올 때 로드하는 방식입니다.
4. CDN을 활용하면 사용자와 가까운 서버에서 이미지를 제공받을 수 있어 로딩 속도를 더욱 향상시킬 수 있습니다.

---

### 자바스크립트는 싱글 스레드 언어인데, 어떻게 동시에 여러 작업들을 수행하나요?

자바스크립트는 싱글 스레드이지만 비동기 처리를 통해 여러 작업을 동시에 처리하는 것처럼 동작합니다.
이는 이벤트 루프와 Web API, 그리고 태스크 큐라는 시스템을 통해 가능합니다.
비동기 작업이 발생하면 Web API로 위임되고, 작업이 완료되면 해당 콜백은 태스크 큐에 들어갑니다.
이벤트 루프는 콜 스택이 비어있을 때 태스크 큐에서 작업을 가져와 실행합니다.
이러한 방식으로 메인 스레드를 블로킹하지 않으면서도 여러 작업을 처리할 수 있습니다.

##### 예상 꼬리 질문

### 태스크 큐의 종류에는 어떤 것들이 있나요?

태스크 큐는 매크로태스크 큐와 마이크로태스크 큐로 나뉩니다.

1. 매크로태스크 큐는 setTimeout이나 setInterval 같은 일반적인 비동기 작업의 콜백이 들어가고,
2. 마이크로태스크 큐는 Promise의 then 핸들러와 같은 우선순위가 높은 작업들이 들어갑니다.

이벤트 루프는 매크로태스크를 하나 처리한 후, 항상 마이크로태스크 큐를 모두 비운 다음에 다음 매크로태스크를 처리합니다.
이러한 특성 때문에 Promise 체인이 setTimeout보다 먼저 실행되는 것입니다.

---

### 타입스크립트의 타입과 인터페이스의 차이점을 설명해주세요.

타입스크립트에서 타입과 인터페이스는 각각 다른 특징과 용도를 가지고 있습니다.

1. 인터페이스는 객체의 구조를 정의하고 확장하는 데 특화되어 있습니다. 특히 선언 병합이라는 특별한 기능이 있어서, 같은 이름의 인터페이스를 여러 번 선언하면 자동으로 속성들이 합쳐집니다. 이는 라이브러리의 타입을 확장할 때 유용하게 사용됩니다.
2. 타입은 더 다양한 형태의 타입 정의가 가능합니다. 유니온(|)이나 인터섹션(&) 연산자를 사용할 수 있고, 튜플이나 기타 복잡한 타입 표현이 가능합니다. 단, 한 번 선언한 타입은 재선언이 불가능하다는 제약이 있습니다.

---

### 시맨틱 마크업이란 무엇이며, 왜 중요한가요?

시맨틱 마크업은 HTML 요소를 의미에 맞게 사용하는 방식입니다. 단순히 스타일링을 위해 div나 span을 사용하는 대신, header, nav, main, article 같은 의미를 가진 태그를 적절히 사용하는 것을 말합니다.
이는 두 가지 측면에서 매우 중요합니다.

1. 웹 접근성 측면에서, 스크린 리더와 같은 보조 기술이 콘텐츠의 구조를 정확히 파악하고 사용자에게 전달할 수 있게 합니다.
2. SEO 측면에서, 검색 엔진이 페이지의 구조와 콘텐츠의 중요도를 더 정확하게 파악할 수 있게 도와줍니다.

##### 예상 꼬리 질문

### CSR에서도 시맨틱 마크업이 SEO에 영향을 미치나요?

네, 최근에는 CSR 환경에서도 시맨틱 마크업이 SEO에 영향을 미칩니다.
구글과 같은 현대의 검색 엔진들은 자바스크립트를 실행하고 렌더링된 결과물을 분석할 수 있게 발전했기 때문입니다.
따라서 CSR 애플리케이션에서도 적절한 시맨틱 마크업을 사용하면 검색 엔진이 콘텐츠를 더 잘 이해하고 평가할 수 있어, 검색 결과 순위에 긍정적인 영향을 미칠 수 있습니다.

---

### ES6에 대해서 설명해주세요.

ES6(ECMAScript 2015)는 자바스크립트의 가장 큰 업데이트 중 하나로, 개발자들의 생산성과 코드 품질을 크게 향상시켰습니다.
ES6는 여러 가지 중요한 기능들을 도입했는데요,
변수 선언을 위한 let과 const, 간결한 함수 표현을 위한 화살표 함수,
객체 지향 프로그래밍을 위한 클래스 문법, 코드 모듈화를 위한 import/export 시스템 등이 대표적입니다.
또한 템플릿 리터럴, 구조 분해 할당, Promise, 스프레드 연산자 같은 편리한 기능들도 추가되었습니다.

##### 예상 꼬리 질문

### ES6의 주요 기능들을 자세히 설명해주세요.

1. 변수 선언 방식이 크게 개선되었습니다. let은 블록 스코프 변수를 선언할 때 사용하고, const는 재할당이 필요 없는 상수를 선언할 때 사용합니다. 이를 통해 var가 가지고 있던 여러 문제점들을 해결할 수 있게 되었습니다.
2. 화살표 함수는 기존의 함수 표현식을 더 간단하게 작성할 수 있게 해주었고, this 바인딩도 더 예측 가능하게 만들어주었습니다.
3. 클래스 문법의 도입으로 객체 지향 프로그래밍이 더 직관적으로 변했습니다. 생성자, 상속, 메서드 정의 등을 더 명확하게 표현할 수 있게 되었습니다.
4. 모듈 시스템도 큰 변화였습니다. import와 export를 통해 코드를 모듈 단위로 관리하고 재사용할 수 있게 되어, 대규모 애플리케이션 개발이 더 수월해졌습니다.

그 밖에도 템플릿 리터럴로 문자열 내에 변수를 쉽게 포함할 수 있게 되었고, 구조 분해 할당으로 객체나 배열의 값을 편리하게 추출할 수 있게 되었습니다. 스프레드 연산자는 배열이나 객체를 쉽게 복사하거나 합칠 수 있게 해주었습니다.

---

### Promise에 대해서 설명해주세요.

Promise는 자바스크립트에서 비동기 작업을 더 편리하게 처리할 수 있게 해주는 객체입니다.
비동기 작업의 최종 완료 또는 실패를 나타내며, 세 가지 상태(대기, 이행, 거부)를 가질 수 있습니다.
이를 통해 비동기 작업의 결과를 예측 가능하게 처리할 수 있습니다.

### Promise의 세 가지 상태에 대해 설명해주세요.

Promise는 세 가지 상태를 가집니다.

1. 대기(Pending) 상태는 비동기 작업이 아직 완료되지 않은 초기 상태입니다. Promise가 생성되면 이 상태에서 시작합니다.
2. 이행(Fulfilled) 상태는 비동기 작업이 성공적으로 완료된 상태입니다. 이때 then() 메서드를 통해 결과값을 받아서 처리할 수 있습니다.
3. 거부(Rejected) 상태는 비동기 작업이 실패하거나 오류가 발생한 상태입니다. catch() 메서드를 통해 오류를 처리할 수 있습니다.

### Promise와 콜백의 차이점은 무엇인가요?

Promise는 콜백 패턴의 여러 단점을 보완하기 위해 도입되었습니다.

첫째, 에러 처리가 더 간단합니다. Promise는 catch를 통해 모든 에러를 한 곳에서 처리할 수 있지만, 콜백은 각각의 콜백마다 에러 처리를 해야 합니다.
둘째, 코드 가독성이 좋습니다. Promise는 then을 체이닝하는 방식으로 코드를 작성할 수 있어 흐름을 이해하기 쉽습니다. 반면 콜백은 중첩이 깊어질수록 코드가 복잡해지는 '콜백 헬' 문제가 있습니다.
셋째, 비동기 작업의 순서를 더 쉽게 제어할 수 있습니다. Promise는 then을 통해 작업 순서를 명확하게 보장할 수 있지만, 콜백은 여러 비동기 작업의 순서를 관리하기가 어렵습니다.

---

### JWT(JSON Web Token)에 대해 설명해주세요.

JWT는 당사자 간에 안전하게 정보를 주고받을 수 있게 해주는 토큰 기반의 인증 방식입니다.
Header, Payload, Signature라는 세 부분으로 구성되어 있으며, 주로 사용자 인증과 정보 교환을 위해 사용됩니다.
사용자가 로그인하면 서버는 JWT를 발급하고, 클라이언트는 이후 요청 시마다 이 토큰을 함께 전송하여 자신을 인증합니다.

### JWT의 각 부분은 어떤 역할을 하나요?

JWT의 각 부분은 고유한 역할을 갖고 있습니다.

1. Header는 토큰의 타입과 사용된 암호화 알고리즘 정보를 포함합니다. 예를 들어 HMAC SHA256이나 RSA와 같은 서명 알고리즘 정보가 여기에 들어있습니다.
2. Payload에는 전달하고자 하는 실제 데이터가 담깁니다. 사용자 ID, 권한 정보, 만료 시간 등 필요한 클레임 정보들을 포함합니다.
3. Signature는 Header와 Payload를 기반으로 비밀키를 사용해 생성된 서명입니다. 이를 통해 토큰의 무결성을 검증할 수 있습니다.

### JWT의 장단점은 무엇인가요?

JWT는 확실한 장점과 단점을 가지고 있습니다.

1. 장점으로는 서버가 상태를 유지할 필요가 없어 서버 자원을 효율적으로 사용할 수 있고, 여러 서버 간에 토큰을 쉽게 공유할 수 있다는 점이 있습니다.
2. 단점은 토큰 크기가 세션 ID에 비해 크다는 점과, 한번 발급된 토큰은 만료되기 전까지 계속 유효하기 때문에 토큰이 탈취되면 보안상 위험할 수 있다는 점입니다.

### JWT는 어디에 저장하는 것이 좋을까요?

보안을 고려할 때, JWT는 브라우저에서는 httpOnly 플래그가 설정된 쿠키에 저장하는 것이 권장됩니다. localStorage도 사용할 수 있지만 XSS 공격에 취약할 수 있습니다.
모바일 환경에서는 각 플랫폼의 보안 저장소를 활용하는 것이 좋습니다. iOS에서는 Keychain, Android에서는 Keystore와 같은 시스템 수준의 보안 저장소를 사용하면 안전하게 토큰을 보관할 수 있습니다.

---

### useEffect가 호출되는 시점에 대해 설명해 주세요.

useEffect는 리액트에서 사이드 이펙트를 처리하기 위한 Hook인데요, 컴포넌트가 렌더링된 이후에 실행됩니다.
여기서 사이드 이펙트란 API 호출이나 구독 설정, DOM 조작 같은 작업들을 말하는데요, 이런 작업들은 렌더링이 완료된 후에 수행하는 것이 좋습니다.
useEffect의 실행 시점은 의존성 배열을 어떻게 설정하느냐에 따라 달라지는데요,

1. 빈 배열을 전달하면 컴포넌트가 처음 마운트될 때만 실행되고,
2. 특정 값을 배열에 넣으면 그 값이 변경될 때마다 실행됩니다.
3. 의존성 배열을 아예 생략하면 모든 렌더링 후에 실행됩니다.

또한 useEffect에서 함수를 반환할 수 있는데 이를 클린업 함수라고 합니다.
이 함수는 컴포넌트가 화면에서 사라지거나, 다음 useEffect가 실행되기 전에 호출됩니다.
예를 들어 이벤트 리스너를 등록했다면, 클린업 함수에서 이를 제거해주는 방식입니다.

---

### 웹 보안과 관련된 주요 취약점과 대응 방안에 대해 설명해주세요.

웹 보안에서 가장 중요한 취약점과 그 대응 방안을 몇 가지 말씀드리겠습니다.

1. XSS(Cross-Site Scripting) 공격이 있습니다. 이는 악성 스크립트를 웹 페이지에 삽입하여 실행하는 공격인데요, 이를 방지하기 위해서는 모든 사용자 입력값을 적절히 이스케이프 처리해야 합니다.
2. CSRF(Cross-Site Request Forgery) 공격이 있습니다. 이는 사용자가 의도하지 않은 요청을 강제로 발생시키는 공격인데요, 이를 막기 위해서는 서버에서 생성한 CSRF 토큰을 사용해 요청을 검증하는 방식을 사용합니다.
3. 데이터 저장과 관련된 보안도 중요합니다. 클라이언트 측 저장소인 localStorage나 sessionStorage는 XSS 공격에 취약하므로 민감한 정보는 저장하지 않아야 하고, 쿠키를 사용할 때는 HttpOnly, Secure, SameSite 같은 보안 옵션을 적절히 설정해야 합니다.
4. 모든 API 통신은 반드시 HTTPS를 사용해야 하며, Same-Origin 정책을 기본으로 하고 필요한 경우에만 CORS를 허용하는 것이 좋습니다. 이를 통해 데이터 전송 과정에서의 보안을 강화할 수 있습니다.

### 리액트에서 컴포넌트란 무엇인가요?

리액트 컴포넌트는 UI를 구성하는 독립적이고 재사용 가능한 코드 조각입니다.
웹 서비스의 UI를 작은 단위로 나누어 관리할 수 있게 해주는 개념입니다. 컴포넌트는 클래스형과 함수형으로 나눌 수 있는데, 최근에는 React Hooks의 등장으로 함수형 컴포넌트가 주로 사용됩니다.
리액트 컴포넌트의 주요 특징으로는 재사용성, 독립성, 그리고 단방향 데이터 흐름을 들 수 있습니다.
컴포넌트는 props를 통해 데이터를 전달받고, state를 통해 내부 상태를 관리하며, lifecycle 메서드나 hooks를 통해 컴포넌트의 생명주기를 제어할 수 있습니다.
컴포넌트를 효과적으로 사용하기 위해서는 단일 책임 원칙을 준수하고, props와 state를 적절히 활용하며, 필요한 경우 성능 최적화를 고려해야 합니다.
특히 대규모 애플리케이션에서는 컴포넌트 구조를 잘 설계하는 것이 프로젝트의 성공을 좌우하는 중요한 요소가 됩니다.

##### 예상 꼬리 질문

### 컴포넌트 설계 시 중요하게 고려해야 하는 사항에는 어떤 것들이 있나요?

1. 단일 책임 원칙(Single Responsibility)이 가장 중요합니다. 하나의 컴포넌트는 한 가지 역할만 수행하도록 설계해야 합니다. 예를 들어, 데이터 fetching과 UI 렌더링을 분리하거나, 폼 로직과 표시 로직을 별도의 컴포넌트로 나누는 것이 좋습니다.
2. 재사용성과 유연성도 핵심 고려사항입니다. props를 통해 다양한 상황에서 활용할 수 있도록 컴포넌트를 설계해야 합니다. 예를 들어 버튼 컴포넌트는 크기, 색상, 텍스트 등을 props로 받아 여러 상황에서 재사용할 수 있어야 합니다.
3. 성능 최적화도 중요한 요소입니다. React.memo, useMemo, useCallback 등을 활용해 불필요한 리렌더링을 방지하고, 컴포넌트 트리의 깊이를 적절히 유지하여 성능을 최적화해야 합니다.
4. 마지막으로 명확한 네이밍과 문서화도 중요합니다. 컴포넌트의 이름은 그 역할을 명확히 나타내야 하며, props의 타입과 용도를 문서화하여 다른 개발자들이 쉽게 이해하고 사용할 수 있도록 해야 합니다.
   이러한 원칙들은 상황에 따라 유연하게 적용되어야 합니다. 작은 프로젝트에서는 과도한 분리가 오히려 복잡성을 높일 수 있으므로, 프로젝트의 규모와 요구사항에 맞춰 적절한 균형을 찾는 것이 중요합니다.

### 타입스크립트를 사용하는 이유를 설명해주세요.

타입스크립트는 자바스크립트에 타입 시스템을 추가한 언어입니다. 정적 타입을 지원하여 컴파일 단계에서 버그를 미리 발견할 수 있게 해주며, 강력한 자동 완성 기능으로 개발 생산성을 크게 높여줍니다.
초기 설정과 학습에 시간이 필요하다는 단점이 있지만, 프로젝트의 규모가 커질수록 타입스크립트가 주는 이점이 더욱 커지기 때문에 현대 웹 개발에서 필수적인 도구로 자리잡았습니다.
