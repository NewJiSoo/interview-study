### ❓리액트에서 성능 최적화를 위한 방법들을 설명해주세요.

> 리액트에서 성능 최적화 방법은 메모이제이션을 활용한 방법이 있습니다.
> ‘React.memo’, ‘useMemo’, ‘useCallback’과 리액트 내장 함수를 활용하여 성능 최적화를 할 수 있습니다. 또한 ‘React.lazy’ 와 ‘Suspense’를 사용하여 코드 스플리팅을 할수도 있습니다.

##### 💡예상 꼬리 질문

### ❓React.memo, useMemo, useCallback의 차이점

> ‘React.memo’는 컴포넌트 자체를 메모이제이션하여 재랜더링을 방지합니다. 일반적으로 값이 자주 변하지 않지만 컴포넌트가 리렌더링 되면 성능에 영향을 주는 상황에서 유용합니다.
> ‘useMemo’는 특정 값의 계산한 결과를 메모이제이션 합니다. 값이 복잡하거나 시간이 오래 걸리는 연산이 경우 해당 값이 변경되지 않는 한 이전 계산 결과를 재사용합니다.
> ‘‘useCallback’은 함수 자체를 메모이제이션합니다. 자식 컴포넌트에 함수를 props를 전달할 때 불필요한 리렌더링을 방지할 수 있습니다.
> `useMemo`와 `useCallback`은 단순한 값을 계산하는 데 사용하는 것 보다는 비용이 높은 연산이거나, 자식 컴포넌트 리렌더링이 성능에 중요한 경우에만 사용하는 것이 좋습니다.

---

### ❓브라우저 렌더링 파이프라인에 대해서 설명해주세요.

> 먼저 HTML DOM 트리를 생성합니다. 그다음에 CSSOM 트리를 생성하게 됩니다.
> 그 후 HTML DOM 트리와 CSSOM 트리를 결합하여 렌더 트리를 생성하게 됩니다.
> 그리고 레이아웃 크기를 계산하여 페인팅 됩니다. 마지막으로 컴포지팅 단계로 레이어를 결합하여 최종 화면을 구성합니다. 이러한 과정이 순차적으로 이루어지며 웹페이지가 최종적으로 사용자에게 렌더링이 됩니다.

---

### ❓인터넷 창에서 url을 입력하면 무슨 일이 일어나는지 설명해주세요.

> 첫번째로 DNS 조회가 일어납니다. 브라우저에 캐시된 DNS 기록을 먼저 확인 후 없으면 DNS 서버에 요청하여 url에 해당하는 IP 주소를 얻습니다. 그후에 TCP 연결을 수립합니다. 세번째는 HTTP 요청입니다. TCP 연결이 수립되면 브라우저는 HTTP 또는 HTTPS 요청을 보냅니다. 이 과정에서 브라우저와 서버가 암호화된 연결을 설정하기 위해 보안 인증서를 교환하고 암호화 키를 협상합니다. 네번째로 서버의 응답이 옵니다. 리소스를 브라우저에게 응답으로 보냅니다. 마지막으로 받은 리소스를 바탕으로 브라우저가 렌더링 됩니다.

---

### ❓리액트의 render phase와 commit phase에 대해서 설명해주세요.

> 두가지 모두, 리액트 렌더링 단계와 관려되어 있는데요. 먼저 render phase는 리액트가 변화된 상태나 props에 따라 어떤 UI가 변경되어야 할지를 결정하는 단계입니다. 이 과정에서는 실제로 DOM을 업데이트하지 않고, 가상 DOM에서 계산하여 비교합니다. 다음으로 commit phase는 실제로 변화된 UI를 DOM에 반영하는 단계입니다. 이때 리액트는 가상 DOM에서 계산된 결과를 실제 DOM에 적용하고, 변화된 UI를 브라우저에 렌더링합니다. 이 과정에서는 useEffect와 같은 사이드 이펙트가 발생하는 훅들이 실행됩니다. **요약해서 말씀드려보자면 render phase는 변화된 UI를 결정하는 과정이고, commit phase는 그 결정된 결과를 실제로 반영하는 단계입니다.**

##### 💡예상 꼬리 질문

### ❓그럼 render phase와 commit phase는 어떻게 동기화되나요?

> 두가지의 단계로 말씀드릴 수 있습니다. 단계적 진행과 병목 관리입니다. 첫번째로 render phase가 완료되면 리액트는 즉시 commit phase를 실행하지 않고, 다른 높은 우선순위 작업이 있다면 먼저 처리한 후 나중에 commit phase를 실행할 수 있습니다. 이를 통해 React는 동기화가 필요한 작업을 효율적으로 관리하여 사용자 경험을 개선합니다. 두번째로 병목 관리입니다. render phase에서 모든 변경 사항이 Fiber Tree에 준비된 상태에서 commit phase로 넘어가므로, render와 commit 단계의 일관성이 유지됩니다. 이렇게 두 단계는 순차적으로 작동하여, UI가 정확하게 동기화되고 불필요한 재렌더링을 방지합니다.

---

### ❓자바스크립트 호이스팅에 대해서 설명해주세요.

> 호이스팅은 자바스크립트 코드가 실행하기 전 변수와 함수 선언을 코드 최상단으로 끌어 올리는 것처럼 동작하는 것입니다. 이를 통해 선언된 위치와 상관없이 변수를 사용할 수 있는 것 처럼 보일 수 있습니다. 하지만 호이스팅은 선언의 호이스팅이라 값의 할당까 끌어리지는 않습니다. var는 선언만 호이스팅 되어 초기화 전에 undefined가 되며 let과 const는 TDZ로 인해 초기화 전에 접근하면 레퍼런스 에러를 발생 시킵니다.

---

### ❓쿠키, 세션, 웹스토리지의 차이를 설명해보세요.

> 세가지 모두 웹에서 데이터를 저장하는 방식입니다. 먼저 쿠키는 클라이언트와 서버간의 데이터를 주고 받기 위해 사용됩니다. http의 무상태성을 위해 생겼습니다. 클라이언트의 브라우저에 저장되고 매 http 요청 시에 서버로 자동 전송됩니다. 그 다음 세션은 서버에서 사용자 상태를 유지하는 방법입니다. 클라이언트가 브라우저를 닫거나 특정 시간 동안 활동하지 않으면 만료됩니다. 사용자의 상태를 서버에 저장하고 세션 ID를 클라이언트에 쿠키로 저장하게 됩니다. 웹 스토리지는 크게 로컬스토리지와 세션스토리지가 있습니다. 로컬스토리지는 브라우저에 영구적으로 저장되고, 브라우저를 종료해도 데이터가 유지됩니다. 세션 스토리지는 브라우저의 탭이나 창이 닫히면 삭제됩니다. 두가지 모두 데이터를 브라우저에 저장하는 방법이고 서버로 전송 되지 않는다는 장점이 있으나, 민감한 정보는 피해 사용하는 것이 좋습니다.

---

### ❓자바스크립트 함수에 대해서 설명해주세요.

> 자바스크립트 함수는 `일급 객체`로써 취급되며 클로저, 고차함수, 화살표 함수 등 여러 특징이 있습니다. 먼저 일급객체로서의 특징은 자바스크립트 함수가 변수에 할당 되거나 다른 함수에 인자로 전달되거나 반환 될 수 있다는 점입니다. 이를 통해 매우 유연하고, 고차함수를 포함한 다양한 패턴을 구현할 수 있게됩니다. 두번째로 이름 없는 함수를 정의할 수 있습니다. 세번째로 함수 선언은 코드가 실행되기 전에 호스팅되어, 함수 선언 이전에 호출할 수 있습니다. 반면 함수 표현식은 변수에 할당된 후에 사용할 수 있습니다. 네번째는 클로저 함수를 지원합니다. 자신이 선언된 스코프를 기억하고 그 외부 스코프에 접근할 수 있습니다. 다음으로는 고차함수가 특징 입니다. 마지막으로는 화살표 함수라는 간결한 문법을 제공합니다.

---

### ❓CommonJS와 ES Module의 차이점에 대해서 설명해주세요.

> 두가지는 자바스크립트에서 모듈을 관리하고 불러오는 주요 방식입니다. 먼저 Common Js는 node.js 환경에서 사용되며 모듈을 동기적으로 불러옵니다다. 모듈이 로드될때까지 다음 코드가 실행되지 않습니다. common Js는 `require` 키워드를 사용하여 모듈을 가져오고 `module.export` 를 통해 내보냅니다. 반면 ES Module은 자바스크립트의 공식 표준 모듈 시스템으로 ES6 부터 도입되었습니다. 이 모듈은 브라우저와 node.js 환경에서 모두 사용할수 있고, 비동기적으로 로드합니다. 모듈을 가져올때는 import 키워드를 사용하고, 내보낼 때는 export 키워드를 사용합니다. 최근에는 ESM 사용이 증가하는 추세입니다. 브라우저와 서버의 모듈 호환성을 위해 풀스택 어플리케이션에서도 ESM이 많이 사용됩니다.

---

### ❓이벤트 전파(event propagation)에 대해서 설명해주세요.

> 이벤트 전파는 DOM에서 이벤트가 발생했을 때, 그 이벤트가 어떤 방식으로 전파되는지 설명하는 개념입니다. 이벤트 전파는 3단계로 나뉩니다. -캡처링, -타겟, -버블링 입니다. 첫번째 캡처링은 돔트리 최상위 요소에서 시작하여 이벤트가 발생한 요소로 향해 내려가는 단계입니다. 이 과정에서 상위 요소의 이벤트 리스너가 있으면 그 순서대로 실행됩니다.
> 두번째는 타겟 단계 입니다. 이벤트가 실제로 발생한 타겟 요소에 도달하는 단계 입니다. 타겟 요소에 등록된 이벤트 리스너가 이 시점에서 실행됩니다.
> 세번째는 버블링 단계 입니다. 타겟 요소에서 이벤트가 발생한 후 다시 DOM트리의 상위 요소로 이벤트가 전파되어 올라가는 단계입니다. 이 과정에서 상위 요소들에 등록된 이벤트 리스너가 실행 될 수 있습니다.

---

### ❓웹 애플리케이션의 성능을 최적화할 수 있는 방법들에 대해서 아는대로 설명해주세요.

> 첫번째로는 코드 스플리팅이 있습니다. 사용자가 즉시 필요한 부분만 먼저 로드하여 페이지 로딩 속도를 개선할 수 있습니다.
> 두번째로는 레이지 로딩 기법을 사용하여 이미지나 비디오 같은 무거운 리소스를 사용자가 실제로 볼 때만 로드하는 방식입니다.
> 세번째로 이미지 파일의 크기를 알맞게 줄이거나 Webp같은 가벼운 포맷으로 변환하는 방법이 있습니다.
> 또한, 캐싱을 활용하면 한번 로딩된 리소슬르 다시 다운로드 하지 않고 브라우저가 캐시된 데이터를 재사용하여 성능을 크게 향상 시킬 수 있습니다.

---

### ❓디바운스와 쓰로틀에 대해서 각각 설명해주세요.

> 먼저 디바운스는 연속적으로 이벤트가 발생할때 마지막 이벤트가 발생한 후 일정 시간이 지난 후에 이벤트 핸들러가 실행되는 방식입니다. 예를 들면 검색창에 사용자가 키를 입력할때마다 요청을 보내면 부하가 많이 되게 되는데, 사용자가 입력을 멈추고 일정 시간이 지난면 검색 요청을 보내는 방식을 적용할 수 있습니다.
> 그다음 쓰로틀은 일정 간격동안 발생한 이벤트 중에 마지막 이벤트만 처리하는 방식입니다. 이벤트가 계속 발생하더라도 설정된 시간동안은 한번만 이벤트 핸들러가 실행됩니다. 사용자가 연속 클릭을 하더라도 일정 시간 내에 한번만 처리하게 됩니다.

##### 💡예상 꼬리 질문

### ❓디바운스와 쓰로틀 중에서 무한 스크롤 구현 시 어떤 방식을 선택하시겠습니까? 그 이유는 무엇인가요?

> 무한 스크롤에서는 쓰로틀을 사용하는 것이 더 적합합니다. 디바운스를 적용할경우 스크롤이 멈춘 후에야 데이터를 불러오기 때문에 지연이 발생될 수 있고, 쓰로틀은 바로 한번 수행되므로 더 자연스로운 경험을 제공할 수 있습니다.

---

### ❓리액트에서 index를 key값으로 사용하면 안되는 이유에 대해서 설명해주세요.

> 키값은 고유한 값으로 이루어져야합니다. 그 이유는 리액트에서 key를 통해 어떤 요소가 변경, 추가, 삭제되었는지 추적하는데, index를 key로 사용하면 배열의 순서가 바뀌었을때 리액트가 요소를 잘못 인식할 수 있습니다. 배열에 새로운 요소가 추가되면 그 뒤에 있는 요소의 인덱스가 모두 바뀌게 됩니다. 그럼 리액트는 새로운 요소로 인식하게 되어 불필요한 리렌더링을 하거나 요소의 상태를 잘못 처리 할 수 있습니다.

##### 💡예상 꼬리 질문

### ❓key로 사용되는 고유한 값의 생성 방법에는 어떤 것들이 있나요?

> 주로 uuid 와 같은 라이브러리를 통해 고유한 id를 생성합니다.
