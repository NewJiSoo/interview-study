### ❓리액트에서 성능 최적화를 위한 방법들을 설명해주세요.

> 리액트에서 성능 최적화 방법은 메모이제이션을 활용한 방법이 있습니다.
> ‘React.memo’, ‘useMemo’, ‘useCallback’과 리액트 내장 함수를 활용하여 성능 최적화를 할 수 있습니다. 또한 ‘React.lazy’ 와 ‘Suspense’를 사용하여 코드 스플리팅을 할수도 있습니다.

##### 💡예상 꼬리 질문

### ❓React.memo, useMemo, useCallback의 차이점

> ‘React.memo’는 컴포넌트 자체를 메모이제이션하여 재랜더링을 방지합니다. 일반적으로 값이 자주 변하지 않지만 컴포넌트가 리렌더링 되면 성능에 영향을 주는 상황에서 유용합니다.
> ‘useMemo’는 특정 값의 계산한 결과를 메모이제이션 합니다. 값이 복잡하거나 시간이 오래 걸리는 연산이 경우 해당 값이 변경되지 않는 한 이전 계산 결과를 재사용합니다.
> ‘‘useCallback’은 함수 자체를 메모이제이션합니다. 자식 컴포넌트에 함수를 props를 전달할 때 불필요한 리렌더링을 방지할 수 있습니다.
> `useMemo`와 `useCallback`은 단순한 값을 계산하는 데 사용하는 것 보다는 비용이 높은 연산이거나, 자식 컴포넌트 리렌더링이 성능에 중요한 경우에만 사용하는 것이 좋습니다.

---

### ❓브라우저 렌더링 파이프라인에 대해서 설명해주세요.

> 먼저 HTML DOM 트리를 생성합니다. 그다음에 CSSOM 트리를 생성하게 됩니다.
> 그 후 HTML DOM 트리와 CSSOM 트리를 결합하여 렌더 트리를 생성하게 됩니다.
> 그리고 레이아웃 크기를 계산하여 페인팅 됩니다. 마지막으로 컴포지팅 단계로 레이어를 결합하여 최종 화면을 구성합니다. 이러한 과정이 순차적으로 이루어지며 웹페이지가 최종적으로 사용자에게 렌더링이 됩니다.

---

### ❓인터넷 창에서 url을 입력하면 무슨 일이 일어나는지 설명해주세요.

> 첫번째로 DNS 조회가 일어납니다. 브라우저에 캐시된 DNS 기록을 먼저 확인 후 없으면 DNS 서버에 요청하여 url에 해당하는 IP 주소를 얻습니다. 그후에 TCP 연결을 수립합니다. 세번째는 HTTP 요청입니다. TCP 연결이 수립되면 브라우저는 HTTP 또는 HTTPS 요청을 보냅니다. 이 과정에서 브라우저와 서버가 암호화된 연결을 설정하기 위해 보안 인증서를 교환하고 암호화 키를 협상합니다. 네번째로 서버의 응답이 옵니다. 리소스를 브라우저에게 응답으로 보냅니다. 마지막으로 받은 리소스를 바탕으로 브라우저가 렌더링 됩니다.

---

### ❓리액트의 render phase와 commit phase에 대해서 설명해주세요.

> 두가지 모두, 리액트 렌더링 단계와 관려되어 있는데요. 먼저 render phase는 리액트가 변화된 상태나 props에 따라 어떤 UI가 변경되어야 할지를 결정하는 단계입니다. 이 과정에서는 실제로 DOM을 업데이트하지 않고, 가상 DOM에서 계산하여 비교합니다. 다음으로 commit phase는 실제로 변화된 UI를 DOM에 반영하는 단계입니다. 이때 리액트는 가상 DOM에서 계산된 결과를 실제 DOM에 적용하고, 변화된 UI를 브라우저에 렌더링합니다. 이 과정에서는 useEffect와 같은 사이드 이펙트가 발생하는 훅들이 실행됩니다. **요약해서 말씀드려보자면 render phase는 변화된 UI를 결정하는 과정이고, commit phase는 그 결정된 결과를 실제로 반영하는 단계입니다.**

##### 💡예상 꼬리 질문

### ❓그럼 render phase와 commit phase는 어떻게 동기화되나요?

> 두가지의 단계로 말씀드릴 수 있습니다. 단계적 진행과 병목 관리입니다. 첫번째로 render phase가 완료되면 리액트는 즉시 commit phase를 실행하지 않고, 다른 높은 우선순위 작업이 있다면 먼저 처리한 후 나중에 commit phase를 실행할 수 있습니다. 이를 통해 React는 동기화가 필요한 작업을 효율적으로 관리하여 사용자 경험을 개선합니다. 두번째로 병목 관리입니다. render phase에서 모든 변경 사항이 Fiber Tree에 준비된 상태에서 commit phase로 넘어가므로, render와 commit 단계의 일관성이 유지됩니다. 이렇게 두 단계는 순차적으로 작동하여, UI가 정확하게 동기화되고 불필요한 재렌더링을 방지합니다.

---

### ❓자바스크립트 호이스팅에 대해서 설명해주세요.

> 호이스팅은 자바스크립트 코드가 실행하기 전 변수와 함수 선언을 코드 최상단으로 끌어 올리는 것처럼 동작하는 것입니다. 이를 통해 선언된 위치와 상관없이 변수를 사용할 수 있는 것 처럼 보일 수 있습니다. 하지만 호이스팅은 선언의 호이스팅이라 값의 할당까 끌어리지는 않습니다. var는 선언만 호이스팅 되어 초기화 전에 undefined가 되며 let과 const는 TDZ로 인해 초기화 전에 접근하면 레퍼런스 에러를 발생 시킵니다.

---

### ❓쿠키, 세션, 웹스토리지의 차이를 설명해보세요.

> 세가지 모두 웹에서 데이터를 저장하는 방식입니다. 먼저 쿠키는 클라이언트와 서버간의 데이터를 주고 받기 위해 사용됩니다. http의 무상태성을 위해 생겼습니다. 클라이언트의 브라우저에 저장되고 매 http 요청 시에 서버로 자동 전송됩니다. 그 다음 세션은 서버에서 사용자 상태를 유지하는 방법입니다. 클라이언트가 브라우저를 닫거나 특정 시간 동안 활동하지 않으면 만료됩니다. 사용자의 상태를 서버에 저장하고 세션 ID를 클라이언트에 쿠키로 저장하게 됩니다. 웹 스토리지는 크게 로컬스토리지와 세션스토리지가 있습니다. 로컬스토리지는 브라우저에 영구적으로 저장되고, 브라우저를 종료해도 데이터가 유지됩니다. 세션 스토리지는 브라우저의 탭이나 창이 닫히면 삭제됩니다. 두가지 모두 데이터를 브라우저에 저장하는 방법이고 서버로 전송 되지 않는다는 장점이 있으나, 민감한 정보는 피해 사용하는 것이 좋습니다.

---

### ❓자바스크립트 함수에 대해서 설명해주세요. ✨✨ 다시 공부 및 정리 필요!

> 자바스크립트 함수는 `일급 객체`로써 취급되며 클로저, 고차함수, 화살표 함수 등 여러 특징이 있습니다. 먼저 일급객체로서의 특징은 자바스크립트 함수가 변수에 할당 되거나 다른 함수에 인자로 전달되거나 반환 될 수 있다는 점입니다. 이를 통해 매우 유연하고, 고차함수를 포함한 다양한 패턴을 구현할 수 있게됩니다. 두번째로 이름 없는 함수를 정의할 수 있습니다. 세번째로 함수 선언은 코드가 실행되기 전에 호스팅되어, 함수 선언 이전에 호출할 수 있습니다. 반면 함수 표현식은 변수에 할당된 후에 사용할 수 있습니다. 네번째는 클로저 함수를 지원합니다. 자신이 선언된 스코프를 기억하고 그 외부 스코프에 접근할 수 있습니다. 다음으로는 고차함수가 특징 입니다. 마지막으로는 화살표 함수라는 간결한 문법을 제공합니다.

---

### ❓CommonJS와 ES Module의 차이점에 대해서 설명해주세요.

> 두가지는 자바스크립트에서 모듈을 관리하고 불러오는 주요 방식입니다. 먼저 Common Js는 node.js 환경에서 사용되며 모듈을 동기적으로 불러옵니다다. 모듈이 로드될때까지 다음 코드가 실행되지 않습니다. common Js는 `require` 키워드를 사용하여 모듈을 가져오고 `module.export` 를 통해 내보냅니다. 반면 ES Module은 자바스크립트의 공식 표준 모듈 시스템으로 ES6 부터 도입되었습니다. 이 모듈은 브라우저와 node.js 환경에서 모두 사용할수 있고, 비동기적으로 로드합니다. 모듈을 가져올때는 import 키워드를 사용하고, 내보낼 때는 export 키워드를 사용합니다. 최근에는 ESM 사용이 증가하는 추세입니다. 브라우저와 서버의 모듈 호환성을 위해 풀스택 어플리케이션에서도 ESM이 많이 사용됩니다.

---

### ❓이벤트 전파(event propagation)에 대해서 설명해주세요.

> 이벤트 전파는 DOM에서 이벤트가 발생했을 때, 그 이벤트가 어떤 방식으로 전파되는지 설명하는 개념입니다. 이벤트 전파는 3단계로 나뉩니다. -캡처링, -타겟, -버블링 입니다. 첫번째 캡처링은 돔트리 최상위 요소에서 시작하여 이벤트가 발생한 요소로 향해 내려가는 단계입니다. 이 과정에서 상위 요소의 이벤트 리스너가 있으면 그 순서대로 실행됩니다.
> 두번째는 타겟 단계 입니다. 이벤트가 실제로 발생한 타겟 요소에 도달하는 단계 입니다. 타겟 요소에 등록된 이벤트 리스너가 이 시점에서 실행됩니다.
> 세번째는 버블링 단계 입니다. 타겟 요소에서 이벤트가 발생한 후 다시 DOM트리의 상위 요소로 이벤트가 전파되어 올라가는 단계입니다. 이 과정에서 상위 요소들에 등록된 이벤트 리스너가 실행 될 수 있습니다.

---

### ❓웹 애플리케이션의 성능을 최적화할 수 있는 방법들에 대해서 아는대로 설명해주세요.

> 첫번째로는 코드 스플리팅이 있습니다. 사용자가 즉시 필요한 부분만 먼저 로드하여 페이지 로딩 속도를 개선할 수 있습니다.
> 두번째로는 레이지 로딩 기법을 사용하여 이미지나 비디오 같은 무거운 리소스를 사용자가 실제로 볼 때만 로드하는 방식입니다.
> 세번째로 이미지 파일의 크기를 알맞게 줄이거나 Webp같은 가벼운 포맷으로 변환하는 방법이 있습니다.
> 또한, 캐싱을 활용하면 한번 로딩된 리소슬르 다시 다운로드 하지 않고 브라우저가 캐시된 데이터를 재사용하여 성능을 크게 향상 시킬 수 있습니다.

---

### ❓디바운스와 쓰로틀에 대해서 각각 설명해주세요.

> 먼저 디바운스는 연속적으로 이벤트가 발생할때 마지막 이벤트가 발생한 후 일정 시간이 지난 후에 이벤트 핸들러가 실행되는 방식입니다. 예를 들면 검색창에 사용자가 키를 입력할때마다 요청을 보내면 부하가 많이 되게 되는데, 사용자가 입력을 멈추고 일정 시간이 지난면 검색 요청을 보내는 방식을 적용할 수 있습니다.
> 그다음 쓰로틀은 일정 간격동안 발생한 이벤트 중에 마지막 이벤트만 처리하는 방식입니다. 이벤트가 계속 발생하더라도 설정된 시간동안은 한번만 이벤트 핸들러가 실행됩니다. 사용자가 연속 클릭을 하더라도 일정 시간 내에 한번만 처리하게 됩니다.

##### 💡예상 꼬리 질문

### ❓디바운스와 쓰로틀 중에서 무한 스크롤 구현 시 어떤 방식을 선택하시겠습니까? 그 이유는 무엇인가요?

> 무한 스크롤에서는 쓰로틀을 사용하는 것이 더 적합합니다. 디바운스를 적용할경우 스크롤이 멈춘 후에야 데이터를 불러오기 때문에 지연이 발생될 수 있고, 쓰로틀은 바로 한번 수행되므로 더 자연스로운 경험을 제공할 수 있습니다.

---

### ❓리액트에서 index를 key값으로 사용하면 안되는 이유에 대해서 설명해주세요.

> 키값은 고유한 값으로 이루어져야합니다. 그 이유는 리액트에서 key를 통해 어떤 요소가 변경, 추가, 삭제되었는지 추적하는데, index를 key로 사용하면 배열의 순서가 바뀌었을때 리액트가 요소를 잘못 인식할 수 있습니다. 배열에 새로운 요소가 추가되면 그 뒤에 있는 요소의 인덱스가 모두 바뀌게 됩니다. 그럼 리액트는 새로운 요소로 인식하게 되어 불필요한 리렌더링을 하거나 요소의 상태를 잘못 처리 할 수 있습니다.

##### 💡예상 꼬리 질문

### ❓key로 사용되는 고유한 값의 생성 방법에는 어떤 것들이 있나요?

> 주로 uuid 와 같은 라이브러리를 통해 고유한 id를 생성합니다.

### ❓async/await 에 대해 설명해보세요.

> async/await는 비동기적인 작업을 처리하는 문법입니다. async 함수를 정의하면 함수 내부에서 await 키워드를 이용하여 비동기적으로 처리되는 작업이 완료될 때까지 기다린 후, 결과값을 반환하는 처리를 할 수 있습니다. async/await는 Promise를 기반으로 하여 코드를 보다 간결하고 직관적으로 작성할수 있게 해줍니다. async는 항상 Promise를 반환하며, await를 이용하여 비동기 처리 결과를 기다립니다.

### ❓useEffect와 useLayoutEffect의 차이점에 대해서 설명해주세요.

> useEffect와 useLayoutEffect 두가지 모두 렌더링 시점에 특정 작업을 수행하기 위해 사용됩니다. 하지만 실행되는 타이밍과 용도가 다릅니다. useEffect는 컴포넌트 생애주기에서 마운트된 후 렌더링 완료 후 비동기적으로 실행됩니다. 화면이 실제로 사용자에게 그려진 후에 useEffect가 실행되는 방식입니다. 반면에 useLayoutEffect는 렌더링 후 DOM이 업데이트 되기 직전 시점에 동기적으로 실행됩니다. DOM의 크기를 측정하거나 위치를 조정해야할때 useLayoutEffect를 사용하면 깜빡임이나 불필요한 재렌더링 없이 변경사항이 반영도비니다. 정리하면 렌더링 후 실행되는 비동기 작업에는 useEffect가 적합하고, 레이아웃 작업이나 DOM 조작과 같이 화면이 그려지기 전에 완료되어야 하는 작업에는 useLayoutEffect가 적합합니다.

### ❓SSR(Server Side Rendering)에 대해 설명해주세요.

> SSR은 서버 사이드 렌더링으로 초기화면을 클라이언트가 아닌 서버에서 렌더링하여 완성된 HTML 클라이언트를 내려주는 방식입니다. SSR에서는 서버단에서 HTML을 완성하여 클라이언트에 전송하고, 클라이언트가 HTML을 파싱하여 화면을 그리는 방식입니다. 이후 hydration을 통해 이벤트 리스너 부착 등의 자바스크립트 작업을 수행하여 정적인 화면을 동적으로 전환합니다. 반며에 CSR 방식은 브라우저가 서버로부터 비어있는 뼈대 HTML을 받아온 후 , 필요한 자바스크립트 번들을 다운로드하고 번들을 실행하여 동적으로 컨텐츠를 채웁니다.

##### 💡예상 꼬리 질문

### ❓SSR의 장점은 무엇인가요?

> SEO 측면에서 유리합니다. CSR에 비해서 검색엔진이 크롤링할때 쉽게 컨텐츠를 인식할 수 있습니다. 또한 빠른 초기로딩 속도를 경험할 수 있습니다.

### ❓SSR의 단점은 없나요?

> 상호작용 초기화가 느립니다. 화면에 보여지는 시점과 상호작용하는 시점 사이에 격차가 발생합니다. 또한 구현 난이도가 높습니다. 마지막으로 서버비용이 증가합니다.

### ❓CSS Flexbox와 Grid의 차이점에 대해서 설명해주세요.

> flex와 grid모두 레이아웃을 구성할때 사용하는 CSS 속성입니다. flex는 1차원 레이아웃이지만 grid는 2차원 레이아웃입니다. flex는 주로 행이나 열중에 하나의 방향으로 정렬해야하고, grid는ㄴ 해오가 열을 모두 사용해 요소를 배치할 수 있습니다. 따라서 복잡한 레이아웃을 구성하거나 웹페이지 전체적인 구조를 잡는데 grid가 적합합니다.
> 또한, flex는 콘텐츠 중심으로 콘텐츠가 추가되거나 줄어들 때 유연하게 대처하기 좋습니다. grid는 레이아웃을 중심으로 페이지를 구성하는데 최적화 되어 있습니다.
> 마지막으로 flex는 컨테이너의 크기나 위치에 맞춰 자동 정렬됩니다. 하지만 grid는 행과 열을 사전에 정의하고 그 격자에 요소를 배치하는 방식입니다.

### ❓프론트엔드 E2E 테스트에 대해서 설명해주세요.

> E2E 테스트는 어플리케이션의 사용자 경험을 처음부터 끝까지 시뮬레이션 하여 테스트 하는 방법입니다. 다양한 시나리오를 테스트합니다. 보통은 Cypress, PlayWright 과 같은 도구를 사용하여 작성합니다. 이러한 테스트는 사용자에게 직접적인 영향을 미치는 오류를 조기에 발견할 수 있습니다.

##### 💡예상 꼬리 질문

### ❓유닛 테스트로도 충분히 안정성을 높이고, 리스크를 줄일 수 있지 않나요?

> 유닛 테스트는 개별적인 코드 조각이 제대로 작동하는지는 확인하지만, 전체 시스템의 흐름과 사용자가 실제로 겪는 경험을 확인하지는 않습니다. E2E 테스트는 애플리케이션을 사용자 관점에서 처음부터 끝까지 검사하여, 모든 시스템이 통합적으로 잘 작동하는지 확인합니다.따라서 유닛테스트와 E2E 테스트를 상호 보완적으로 함께 활용하는 것이 좋습니다. 유닛 테스트는 개별 컴포넌트를 신속하고 정확하게 검사하여 디버깅 시간을 줄이고, 코드의 작은 변화가 의도한 대로 작동하는지 확인합니다. 반면, E2E 테스트는 애플리케이션의 중요한 사용자 흐름을 점검하여 배포 후 발생할 수 있는 치명적인 문제를 예방합니다. 이처럼 두 테스트를 함께 활용하면 애플리케이션의 안정성과 신뢰성을 극대화할 수 있습니다.

### ❓이미지 크기가 클 경우 렌더링 속도가 느려질 텐데, 이를 개선하기 위한 방법들을 설명해주세요.

> 세가지로 말씀드릴 수 있습니다. 첫번째로 이미지 포맷 최적화 입니다. webp나 avif와 같은 최신 포맷으로 변환하게 되면 품질을 유지하면서도 파일 크기를 줄여줍니다. 다만 일부 구 버전 브라우저에서는 지원하지 않으므로 호환성을 고려할 필요가 있습니다. 두번째로 이미지 사이즈 조정입니다. 노출 크기에 비해 이미지가 큰 경우 필요한 크기만큼 보여주는 reponsive images 기술을 활용하여 현재 화면 크기에 최적화된 이미지를 선택하여 로드할 수 있습니다. 세번째로 lazy loading을 설정하는 방법입니다. 불필요한 이미지를 사전에 로드 하지 않고 해당 위치에 도달할 때 이미지가 로드 되게 할 수 있습니다. 마지막으로 한가지 더 말씀드리자면 지리적으로 가까운 CDn 서버를 사용하면 로딩 속도를 단축 시킬 수 있습니다.

### ❓자바스크립트는 싱글 스레드 언어인데, 어떻게 동시에 여러 작업들을 수행하나요?

> 자바스크립트는 싱글 스레드 언어입니다. 즉, 한 번에 하나의 작업만을 처리할 수 있는 단일 콜 스택을 가집니다. 하지만 브라우저나 Node.js 환경이 제공하는 비동기 처리 메커니즘 덕분에 여러 작업을 동시에 수행할 수 있습니다. 자바스크립트는 브라우저의 Web API나 Node의 libuv, 이벤트 루프, 태스크 큐를 이용하여 비동기 작업을 동시에 처리합니다. 비동기 작업이 발생하면, 해당 작업(타이머, 네트워크 요청 등)은 브라우저의 Web API에 위임됩니다. Web API에서 비동기 작업이 완료되면, 그 작업은 태스크 큐에 들어가 대기합니다. 이후 이벤트 루프가 콜 스택이 비어있는지 확인한 뒤 태스크 큐에서 대기 중인 작업을 콜 스택으로 가져와 실행합니다. 이러한 구조 덕분에 자바스크립트는 싱글 스레드임에도 비동기적으로 작업을 처리하여 다양한 작업을 효율적으로 관리할 수 있습니다.

##### 💡예상 꼬리 질문

### ❓앞서 말씀하신 태스크 큐의 종류에는 어떤 게 있나요?

> 자바스크립트의 태스크 큐는 크게 매크로태스크 큐와 마이크로태스크 큐로 나뉩니다. 이들 큐는 비동기 작업의 우선순위를 관리하고, 이벤트 루프가 적절한 시점에 콜백을 실행하기 위해 사용됩니다. 매크로태스크 큐는 일반적인 비동기 작업의 콜백이 저장되는 큐입니다. 마이크로태스크 큐는 더 높은 우선순위가 필요한 비동기 작업들이 대기하는 큐입니다. 이벤트 루프는 매크로태스크를 실행하기 전에 항상 마이크로태스크 큐를 먼저 확인하고, 모든 마이크로태스크를 처리한 후 매크로태스크로 넘어갑니다. 이 방식으로 마이크로태스크 큐의 작업은 높은 우선순위로 처리됩니다.

### ❓타입스크립트의 타입과 인터페이스의 차이점을 설명해주세요.

> interface는 객체의 형태를 확장하는 데 용이한 반면, type은 튜플, 인터섹션, 유니온 등을 이용하여 더 복잡한 타입 정의 및 조합을 표현하는 데 용이합니다. 먼저, interface는 선언 병합을 지원해 여러 번 선언할 수 있어, 주로 객체 타입을 확장할 때 유리합니다. 동일한 이름을 가진 interface를 여러 번 선언하면, 이 속성들이 자동으로 합쳐집니다. 반면, type으로 선언한 경우에는 동일한 이름을 중복 선언하면 에러가 발생합니다. 대신, type은 튜플과 같은 복잡한 타입 표현이 가능하며, 복잡한 타입 조합을 위해 인터섹션(&)과 유니온(|) 연산자를 지원합니다.

### ❓시맨틱 마크업이란 무엇이며, 왜 중요한가요?

> 시맨틱 마크업은 HTML 요소를 사용하는 방식으로, 단순히 시각적 목적이 아닌 요소의 의미를 잘 나타내도록 작성하는 방식을 말합니다. 시맨틱 마크업이 중요한 이유는 접근성과 SEO에 유리하기 때문입니다. 시맨틱 요소들은 스크린 리더와 같은 접근성 도구에서 콘텐츠의 구조를 더욱 잘 해석할 수 있게 해 주어 시각장애인이나 노인 등 다양한 사용자층이 사이트를 효과적으로 탐색할 수 있게 합니다. 검색 엔진은 HTML의 시맨틱 구조를 통해 페이지의 구성을 파악합니다. 그렇기에 시맨틱 마크업을 적절히 적용하면, 검색 엔진이 페이지를 올바르게 파악할 수 있고, 그에 따라 검색 결과에서 페이지가 더 잘 노출될 가능성이 높아집니다.

##### 💡예상 꼬리 질문

### ❓CSR(Client Side Rendering)에서도 시맨틱 마크업이 SEO에 영향을 미친다고 보시나요? 만약 그렇다면, 왜 그렇다고 생각하시나요?

> 최근 검색 엔진들은 javascript 렌더링을 지원하는 방향으로 진화하고 있으며, 페이지의 시맨틱 구조를 어느정도 파악 할 수 있습니다. 따라서 시맨틱 마크업을 제대로 적용하면 CSR에서도 검색 엔진이 콘텐츠의 중요한 부분을 더 쉽게 인식하게 되어 검색 결과에 긍정적인 영향을 미칠 수 있습니다.

### ❓ES6에 대해서 아는 대로 설명해 주세요.

> ES6는 2015년에 도입된 자바스크립트의 중요한 업데이트입니다. 개발자들의 코딩 경험을 크게 개선한 여러 가지 새로운 기능들이 추가되었는데요, 특히 let과 const를 통한 변수 선언, 화살표 함수, 클래스 문법, 모듈 시스템, 템플릿 리터럴, 구조 분해 할당, Promise, 스프레드 연산자 등이 대표적입니다.

##### 💡예상 꼬리 질문

### ❓ES6의 주요 기능들을 자세히 설명해주세요.

> let과 const는 변수 선언의 새로운 방식을 제공했습니다. let은 블록 스코프를 가지는 변수를 선언할 때 사용하고, const는 한 번 할당하면 재할당할 수 없는 상수를 선언할 때 사용하죠.

> 화살표 함수도 정말 유용한 기능인데요, 함수를 더 간결하게 작성할 수 있게 해주고, this 바인딩도 렉시컬 스코프를 따르도록 변경되어 더 직관적으로 사용할 수 있게 되었습니다.

> 또한 클래스 문법이 도입되어 객체 지향 프로그래밍을 더 쉽게 할 수 있게 되었습니다. constructor나 extends 같은 키워드를 통해 상속과 인스턴스 생성을 더 명확하게 표현할 수 있게 되었죠.

> import와 export를 사용하는 모듈 시스템도 중요한 변화였는데요, 이를 통해 코드를 더 효율적으로 관리하고 재사용할 수 있게 되었습니다.

> 그 외에도 템플릿 리터럴을 사용하면 문자열 내에 변수를 쉽게 삽입할 수 있고, 구조 분해 할당으로 배열이나 객체의 값을 더 편리하게 추출할 수 있게 되었습니다. 스프레드 연산자는 배열이나 객체를 쉽게 복사하거나 병합할 수 있게 해주었고요.

---

### ❓자바스크립트 Promise에 대해서 아는 대로 설명해주세요.

> Promise는 비동기 작업을 더 효율적으로 처리할 수 있게 해주는 객체입니다. 비동기 작업이 끝날 때까지 기다렸다가 결과를 받을 수 있게 해주죠. Promise는 세 가지 상태를 가지는데요, 대기(pending), 이행(fulfilled), 거부(rejected) 상태가 있습니다.

##### 💡예상 꼬리 질문

### ❓Promise의 세 가지 상태에 대해 자세히 설명해주세요.

> 먼저 대기 상태는 Promise가 생성되고 비동기 작업이 아직 완료되지 않은 초기 상태를 말합니다.

> 이행 상태는 비동기 작업이 성공적으로 완료된 상태인데요, 이때 then() 메서드를 통해 처리 결과를 받아올 수 있습니다.

> 거부 상태는 작업이 실패했거나 오류가 발생한 상태를 말합니다. 이때는 catch() 메서드를 통해 에러를 처리할 수 있죠.

### ❓Promise와 콜백의 차이점은 무엇인가요?

> Promise와 콜백은 몇 가지 중요한 차이점이 있는데요, 먼저 에러 처리 방식이 다릅니다. Promise는 catch를 통해 체계적으로 에러를 처리할 수 있지만, 콜백은 try-catch로 에러를 잡기가 어렵습니다.

> 코드 가독성 측면에서도 차이가 있는데요, Promise는 then을 체이닝하는 방식으로 깔끔하게 코드를 작성할 수 있습니다. 반면 콜백은 중첩이 많아지면 이른바 '콜백 헬'이 발생해서 코드를 이해하기 어려워질 수 있죠.

> 또한 비동기 처리 순서를 보장하는 측면에서도 Promise가 더 우수합니다. Promise는 then을 통해 실행 순서를 명확하게 보장받을 수 있지만, 콜백은 여러 비동기 작업의 순서를 보장하기가 까다롭습니다.
